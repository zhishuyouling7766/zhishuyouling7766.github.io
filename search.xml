<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 函数类型汇总</title>
    <url>/2025/07/18/C++%20%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>本文件整理了 C++ 中常见的各种函数类型，按照不同分类方式组织，方便查阅。</p>
</blockquote>
<hr>
<h2 id="一、按函数的归属和作用域分类"><a href="#一、按函数的归属和作用域分类" class="headerlink" title="一、按函数的归属和作用域分类"></a>一、按函数的归属和作用域分类</h2><h3 id="1-普通-全局函数（自由函数）"><a href="#1-普通-全局函数（自由函数）" class="headerlink" title="1. 普通 全局函数（自由函数）"></a>1. 普通 全局函数（自由函数）</h3><ul>
<li>定义在全局作用域中，与任何类无关：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用方法：</strong> 使用和定义在相同作用域下可直接调用；外部作用域需在.h文件提前声明。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once <span class="comment">//头文件包含保护，QT创建新文件会自带保护宏</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; <span class="comment">//头文件的预处理指令处进行-&gt;声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>); </span><br></pre></td></tr></table></figure>
<ul>
<li>自由函数可以重载，只要函数的<strong>参数个数</strong>或<strong>参数类型</strong>不同，就构成重载（Overload）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意：</strong> ❌ 不允许仅靠返回值重载</li>
<li><strong>注意：</strong> ❌ 全局，更不可以出现相同的函数（参数和返回值和函数名均相同）！！！！</li>
</ul>
<h3 id="2-命名空间-全局函数（自由函数）"><a href="#2-命名空间-全局函数（自由函数）" class="headerlink" title="2. 命名空间 全局函数（自由函数）"></a>2. 命名空间 全局函数（自由函数）</h3><ul>
<li>为了避免命名冲突，<strong>可将自由函数写入命名空间</strong>：</li>
<li>不同命名空间中函数签名可以完全相同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Math1 &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Math2 &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="type">int</span> result1 = Math1::<span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//result1 = 5</span></span><br><span class="line"><span class="type">int</span> result2 = Math2::<span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//result2 = 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用方法：</strong> 外部作用域需在.h文件提前声明，注明命名空间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once <span class="comment">//头文件包含保护，QT创建新文件会自带保护宏</span></span></span><br><span class="line"><span class="keyword">namespace</span> Math1 &#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; <span class="comment">//头文件的预处理指令处进行-&gt;声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> num = Math1::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>); </span><br></pre></td></tr></table></figure>
<h3 id="3-类成员函数"><a href="#3-类成员函数" class="headerlink" title="3. 类成员函数"></a>3. 类成员函数</h3><h4 id="普通成员函数"><a href="#普通成员函数" class="headerlink" title="普通成员函数"></a>普通成员函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::multiply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">MyClass *myClass = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line"><span class="type">int</span> num = myClass-&gt;<span class="built_in">multiply</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyClass类内部、成员函数内调用另一个成员函数：</span></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">multiply</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> num = MyClass::<span class="built_in">getCount</span>();</span><br></pre></td></tr></table></figure>

<h4 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;          <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtual</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::func() 重写虚函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现纯虚函数（必须实现，否则也是抽象类）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pureVirtual</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::pureVirtual() 实现纯虚函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>纯虚函数和Java 接口（<code>interface</code>）类似</p>
</li>
<li><p>虚函数和Java 抽象类（<code>abstract class</code>）类似</p>
</li>
<li><p><code>virtual</code> 是<strong>让函数支持动态绑定</strong>的关键；</p>
</li>
<li><p>如果<strong>不添加 <code>virtual</code> 关键字</strong>，<code>C++</code><strong>可以“重写”函数的名字和参数列表</strong>，但是<strong>不会实现多态</strong>，子类实现的新函数只是语法上的“同名”函数，不具备多态；</p>
</li>
<li><p>推荐使用 <code>override</code> 关键字，可以防止拼写错误或参数不一致导致未正确重写。</p>
</li>
</ul>
<h3 id="3-构造函数与析构函数"><a href="#3-构造函数与析构函数" class="headerlink" title="3. 构造函数与析构函数"></a>3. 构造函数与析构函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>();   <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>();  <span class="comment">// 析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、按函数的特性分类"><a href="#二、按函数的特性分类" class="headerlink" title="二、按函数的特性分类"></a>二、按函数的特性分类</h2><h3 id="1-内联函数（inline）"><a href="#1-内联函数（inline）" class="headerlink" title="1. 内联函数（inline）"></a>1. 内联函数（inline）</h3><p>内联函数是 C++ 中的一种优化机制，通常用于<strong>频繁调用但函数体较小的函数</strong>，以减少函数调用的开销。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>内联函数在编译时，会在调用处将函数的代码展开（替换），而不是跳转执行。</p>
</li>
<li><p>内联函数本质上就是一个“具备参数和类型检查的安全版宏替换”。</p>
</li>
<li><p>运行时没有函数调用的开销（如压栈、跳转、返回），可以提升性能、减少函数调用成本。</p>
</li>
<li><p>C++11 支持内联函数。</p>
</li>
</ul>
<p>⚠️ 注意：<code>inline</code> 只是建议，即使你加了 <code>inline</code>，<strong>编译器不一定会采纳</strong>（例如函数太复杂时）。是否内联，<strong>最终是由编译器自行决定的优化行为</strong>。</p>
<p>如果你希望<strong>强制内联</strong>，可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__forceinline  <span class="comment">// MSVC</span></span><br><span class="line">__attribute__((always_inline))  <span class="comment">// GCC/Clang</span></span><br></pre></td></tr></table></figure>

<h3 id="2-模板函数"><a href="#2-模板函数" class="headerlink" title="2. 模板函数"></a>2. 模板函数</h3><p>模板函数的核心目的就是为了解决“参数类型不确定”的问题，也就是让<strong>一段通用的函数逻辑</strong>可以被<strong>多个不同类型的数据重用</strong>，无需重复写多个重载函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 或 template&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>template&lt;typename T&gt;</code>（或 <code>template&lt;class T&gt;</code>）的意义，是在函数定义前引入一个“模板类型参数” <code>T</code>，告诉编译器：</p>
<p>​         这个函数里的某些类型是泛型的，等到使用（调用）这个函数时再具体确定类型。</p>
<h3 id="3-constexpr-函数"><a href="#3-constexpr-函数" class="headerlink" title="3. constexpr 函数"></a>3. constexpr 函数</h3><p><code>constexpr</code>（<strong>常量表达式函数</strong>）是一个用于在<strong>编译期间求值</strong>的函数或变量修饰符。用于提升性能、简化代码并增强类型安全。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * <span class="built_in">factorial</span>(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>编译期求值</strong>：如果传入的是常量，编译器会在编译时计算结果；</li>
<li><strong>运行期也可用</strong>：如果传入非常量，也可以在运行时执行；</li>
<li><strong>必须只有一条 <code>return</code> 表达式（早期标准）</strong>，C++14 及以后  支持更复杂函数体。</li>
</ul>
<h3 id="4-Lambda-表达式"><a href="#4-Lambda-表达式" class="headerlink" title="4. Lambda 表达式"></a>4. Lambda 表达式</h3><p>Lambda 表达式（又称“匿名函数”）是 C++11 引入的一种简洁方式，用于定义临时的函数对象（functor），常用于 STL 算法、回调、事件处理等场景。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">lambda</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>[]</code>：捕获外部变量。</p>
</li>
<li><p><code>()</code>：参数列表，可省略。</p>
</li>
<li><p><code>-&gt;</code>：返回类型（可省略，自动推导）。</p>
</li>
<li><p><code>&#123;&#125;</code>：函数体。</p>
</li>
</ul>
<h3 id="5-函数对象（仿函数）"><a href="#5-函数对象（仿函数）" class="headerlink" title="5. 函数对象（仿函数）"></a>5. 函数对象（仿函数）</h3><p>在 C++ 中，<strong>函数对象（Function Object）</strong>，又叫做<strong>仿函数（Functor）</strong>，是<strong>重载了 <code>operator()</code> 的类或结构体的对象</strong>。它的行为就像一个函数，可以像调用普通函数一样使用，但又具备类的优势，比如状态保存、模板参数等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Add add;  <span class="comment">// 创建函数对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;  <span class="comment">// 使用函数对象，输出 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>❌<code>struct</code> 不是必须的，可以使用 class、struct 或 typedef 的任何类类型来定义函数对象。</p>
</li>
<li><p>✔<code>operator()</code>是必须的，如果你想让对象“像函数一样调用”。</p>
</li>
<li><p>❌<code>const</code> 不是必须的，加上 <code>const</code> 表示不会修改成员变量的状态，通常推荐加上。</p>
</li>
</ul>
<hr>
<h2 id="三、按调用约定或平台相关特性分类"><a href="#三、按调用约定或平台相关特性分类" class="headerlink" title="三、按调用约定或平台相关特性分类"></a>三、按调用约定或平台相关特性分类</h2><p>“调用约定函数” 通常是指使用**特定调用约定（Calling Convention）*<em>的函数，也就是在汇编层面上定义*<em>参数如何传递</em></em>、<strong>由谁负责清理堆栈</strong>等规则。</p>
<ul>
<li><h3 id="常见调用约定（以-Windows-平台为例）"><a href="#常见调用约定（以-Windows-平台为例）" class="headerlink" title="常见调用约定（以 Windows 平台为例）"></a>常见调用约定（以 Windows 平台为例）</h3></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>关键字</th>
<th>参数顺序</th>
<th>栈清理者</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td>cdecl</td>
<td><code>__cdecl</code></td>
<td>从右到左</td>
<td>调用者</td>
<td align="left">C语言默认调用约定</td>
</tr>
<tr>
<td>stdcall</td>
<td><code>__stdcall</code></td>
<td>从右到左</td>
<td>被调用者</td>
<td align="left">WinAPI 默认使用</td>
</tr>
<tr>
<td>fastcall</td>
<td><code>__fastcall</code></td>
<td>部分参数用寄存器</td>
<td>被调用者</td>
<td align="left">速度较快</td>
</tr>
<tr>
<td>thiscall</td>
<td><code>__thiscall</code></td>
<td>this 指针寄存器</td>
<td>调用者</td>
<td align="left">C++ 成员函数默认调用约定</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="何时需要使用调用约定"><a href="#何时需要使用调用约定" class="headerlink" title="何时需要使用调用约定"></a>何时需要使用调用约定</h3></li>
</ul>
<ol>
<li><strong>与 C 库 或 Windows API 对接</strong>（如 DLL 导出）</li>
<li><strong>跨语言调用函数</strong>（C++&#x2F;C#&#x2F;Delphi等）</li>
<li><strong>嵌入式开发</strong>或<strong>手写汇编优化</strong></li>
<li><strong>实现 Hook 或注入 DLL</strong></li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>分类方式</th>
<th>类型示例</th>
<th>特点说明</th>
</tr>
</thead>
<tbody><tr>
<td>作用域</td>
<td>全局函数、成员函数</td>
<td>是否属于类作用域</td>
</tr>
<tr>
<td>特性</td>
<td>inline、模板、Lambda、仿函数等</td>
<td>编译优化、泛型、函数式编程支持等</td>
</tr>
<tr>
<td>抽象层次</td>
<td>虚函数、纯虚函数</td>
<td>多态、继承</td>
</tr>
<tr>
<td>平台相关</td>
<td>调用约定</td>
<td>Windows API、C 接口交互时常涉及</td>
</tr>
</tbody></table>
<hr>
]]></content>
      <categories>
        <category>C++_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 应用发布签名 Keystore 文件生成记录</title>
    <url>/2025/03/02/Android_Keystore_%E7%94%9F%E6%88%90%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>在 Android 系统中，每一个 APK 必须使用一个有效的签名密钥（Keystore）进行签名，系统才允许其安装与运行。对于 Qt 开发的 Android 应用，生成并配置 <code>.keystore</code> 是发布阶段的必要步骤。</p>
</blockquote>
<hr>
<h2 id="📌-一、Keystore-的作用"><a href="#📌-一、Keystore-的作用" class="headerlink" title="📌 一、Keystore 的作用"></a>📌 一、Keystore 的作用</h2><ul>
<li>🔐 <strong>身份认证</strong>：签名表明这个 APK 来自你这个开发者。</li>
<li>📦 <strong>应用升级绑定</strong>：以后该应用的所有版本必须使用同一个 keystore 签名，否则无法覆盖安装。</li>
<li>🏪 <strong>应用商店要求</strong>：如 Google Play、华为应用市场等，均强制要求 Release APK 必须签名。</li>
</ul>
<hr>
<h2 id="🧪-二、验证系统是否已安装-JDK-和-keytool"><a href="#🧪-二、验证系统是否已安装-JDK-和-keytool" class="headerlink" title="🧪 二、验证系统是否已安装 JDK 和 keytool"></a>🧪 二、验证系统是否已安装 JDK 和 keytool</h2><p>打开命令行（CMD 或 PowerShell），输入以下命令检查：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">keytool -<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">java version &quot;1.8.0_331&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_331-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.331-b09, mixed mode)</span><br><span class="line"></span><br><span class="line">keytool 选项:</span><br><span class="line">-certreq  生成证书签名请求 (CSR)</span><br><span class="line">-genkey    生成密钥对</span><br><span class="line">-help      显示帮助信息</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果 <code>keytool</code> 无法识别，请确认 JDK 安装路径是否已加入环境变量的 Path 中。</p>
<hr>
<h2 id="🧩-三、Keystore-生成命令"><a href="#🧩-三、Keystore-生成命令" class="headerlink" title="🧩 三、Keystore 生成命令"></a>🧩 三、Keystore 生成命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -genkey -v -keystore my-release-key.keystore -<span class="built_in">alias</span> my-key-alias -keyalg RSA -keysize 2048 -validity 10000</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-genkey</code></td>
<td>表示生成密钥对（key pair）</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>输出详细信息</td>
</tr>
<tr>
<td><code>-keystore</code></td>
<td>指定输出的 keystore 文件名</td>
</tr>
<tr>
<td><code>-alias</code></td>
<td>为密钥设置一个别名</td>
</tr>
<tr>
<td><code>-keyalg RSA</code></td>
<td>使用 RSA 加密算法生成密钥</td>
</tr>
<tr>
<td><code>-keysize 2048</code></td>
<td>密钥长度为 2048 位</td>
</tr>
<tr>
<td><code>-validity 10000</code></td>
<td>密钥有效期为 10000 天（约 27 年）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🛡️-四、执行后提示填写信息"><a href="#🛡️-四、执行后提示填写信息" class="headerlink" title="🛡️ 四、执行后提示填写信息"></a>🛡️ 四、执行后提示填写信息</h2><p>依次输入以下信息：</p>
<ol>
<li>密钥库口令（keystore password）</li>
<li>姓名（Your first and last name）</li>
<li>组织单位名（Organizational unit）</li>
<li>组织名（Organization）</li>
<li>城市名（City or Locality）</li>
<li>省份名（State or Province）</li>
<li>国家代码（Country Code，如 <code>CN</code>）</li>
<li>确认信息是否正确（输入 <code>是</code> 或 <code>yes</code>）</li>
<li>可选设置密钥口令（与 keystore 相同可直接回车）</li>
</ol>
<hr>
<h2 id="✅-五、成功结果"><a href="#✅-五、成功结果" class="headerlink" title="✅ 五、成功结果"></a>✅ 五、成功结果</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[正在生成 2048 位 RSA 密钥对，证书采用 SHA256withRSA（有效期为 10000 天）]</span><br><span class="line">[已将密钥库保存到 my-release-key.keystore]</span><br></pre></td></tr></table></figure>

<p>会在当前目录下生成签名文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-release-key.keystore</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-六、在-Qt-Creator-中配置签名"><a href="#🧩-六、在-Qt-Creator-中配置签名" class="headerlink" title="🧩 六、在 Qt Creator 中配置签名"></a>🧩 六、在 Qt Creator 中配置签名</h2><p>在「项目 → 构建与运行 → Android」中设置：</p>
<ul>
<li>Keystore 路径：<code>my-release-key.keystore</code></li>
<li>Store password：刚输入的密钥库口令</li>
<li>Key alias：<code>my-key-alias</code></li>
<li>Key password：与密钥库口令一致或另设</li>
</ul>
<hr>
<h2 id="⚠️-七、可选建议：转为-PKCS12-格式（官方建议）"><a href="#⚠️-七、可选建议：转为-PKCS12-格式（官方建议）" class="headerlink" title="⚠️ 七、可选建议：转为 PKCS12 格式（官方建议）"></a>⚠️ 七、可选建议：转为 PKCS12 格式（官方建议）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore my-release-key.keystore -destkeystore my-release-key.keystore -deststoretype pkcs12</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📁-八、Keystore-文件保存建议"><a href="#📁-八、Keystore-文件保存建议" class="headerlink" title="📁 八、Keystore 文件保存建议"></a>📁 八、Keystore 文件保存建议</h2><p>建议将 keystore 文件统一保存至项目目录外安全位置，</p>
<p>并备份到私密网盘或加密存储设备，防止丢失。</p>
<hr>
<p>生成日期：2025-07-21</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>QT for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 与 Qt 宏机制详解与对比</title>
    <url>/2025/04/30/C++%20%E4%B8%8E%20Qt%20%E5%AE%8F%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<blockquote>
<p>本文档介绍如何在 Qt 定义和运用宏 ， C++的一些常用宏 ， QT标准宏</p>
</blockquote>
<hr>
<h2 id="一、自定义宏（函数宏）"><a href="#一、自定义宏（函数宏）" class="headerlink" title="一、自定义宏（函数宏）"></a>一、自定义宏（函数宏）</h2><h3 id="1-宏的定义"><a href="#1-宏的定义" class="headerlink" title="1. 宏的定义"></a>1. 宏的定义</h3><p>宏是通过 <code>#define</code> 预处理指令定义的，是 <strong>预处理器指令</strong>，在编译前由预处理器进行文本替换。</p>
<h3 id="2-定义语法"><a href="#2-定义语法" class="headerlink" title="2. 定义语法"></a>2. 定义语法</h3><p>使用 <code>#define</code> 预处理指令定义宏函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名(参数1, 参数2, ...) 替换代码</span></span><br></pre></td></tr></table></figure>

<h3 id="3-示例：最大值比较"><a href="#3-示例：最大值比较" class="headerlink" title="3. 示例：最大值比较"></a>3. 示例：最大值比较</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>

<h3 id="4-多行宏"><a href="#4-多行宏" class="headerlink" title="4. 多行宏"></a>4. 多行宏</h3><p>如果宏定义需要跨多行，可以使用反斜杠(<code>\</code>)进行换行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMPLEX_MACRO(a, b, c)  \</span></span><br><span class="line"><span class="meta">    do &#123;                        \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((a) &gt; (b)) &#123;        \</span></span><br><span class="line"><span class="meta">            (c) = (a);          \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> &#123;                \</span></span><br><span class="line"><span class="meta">            (c) = (b);          \</span></span><br><span class="line"><span class="meta">        &#125;                       \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure>

<h3 id="5-括号注意事项"><a href="#5-括号注意事项" class="headerlink" title="5. 括号注意事项"></a>5. 括号注意事项</h3><p>⚠️宏的本质是简单的文本替换，不进行任何计算或语法检查。</p>
<p>❌错误写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) x * x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="built_in">SQUARE</span>(<span class="number">1</span> + <span class="number">2</span>); <span class="comment">// 实际展开为 1 + 2 * 1 + 2 = 5</span></span><br></pre></td></tr></table></figure>

<p>✅正确写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x)) </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="built_in">SQUARE</span>(<span class="number">1</span> + <span class="number">2</span>); <span class="comment">// 展开为 ((1 + 2)*(1 + 2)) = 9</span></span><br></pre></td></tr></table></figure>

<h3 id="6-宏展开时可能造成的副作用-参数自运算问题"><a href="#6-宏展开时可能造成的副作用-参数自运算问题" class="headerlink" title="6. 宏展开时可能造成的副作用,参数自运算问题"></a>6. 宏展开时可能造成的<strong>副作用</strong>,参数自运算问题</h3><p>⚠️自运算型参数被宏多次加载替换，运算时相当于进行顺序的多次自运算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INCREMENT(x) ((x) + (x) + (x))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">INCREMENT</span>(i++); <span class="comment">// 实际展开为 （(i++)+(i++)+(i++)） 即 （1+2+3） = 6</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;i; <span class="comment">// i=4;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-多行宏"><a href="#7-多行宏" class="headerlink" title="7. 多行宏"></a>7. 多行宏</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(msg) \</span></span><br><span class="line"><span class="meta">    std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-无值宏"><a href="#8-无值宏" class="headerlink" title="8. 无值宏"></a>8. 无值宏</h3><p>无值宏 ≈ 一个全局的布尔标志（布尔开关）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_DEBUG  <span class="comment">//完成ENABLE_DEBUG定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_DEBUG</span></span><br><span class="line">    <span class="comment">//会被执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ENABLE_DEBUG  <span class="comment">// ❗取消定义，或项目中无该项定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_DEBUG</span></span><br><span class="line">    <span class="comment">//不会被执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="9-保护宏"><a href="#9-保护宏" class="headerlink" title="9. 保护宏"></a>9. 保护宏</h3><p>保护宏是对无值宏的一种应用</p>
<p>从本质作用上讲，保护宏就是为了防止<strong>头文件被重复包含</strong>，其核心功能只有一点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_HEADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_HEADER_H</span></span></span><br></pre></td></tr></table></figure>

<p>涉及到<strong>头文件嵌套引用时</strong>，它保护了头文件的<strong>实际内容只被编译器看到一次</strong>，即便你在多个地方包含它。</p>
<h4 id="ℹ️保护宏替代方案："><a href="#ℹ️保护宏替代方案：" class="headerlink" title="ℹ️保护宏替代方案："></a>ℹ️保护宏替代方案：</h4><p><code>#pragma once</code> 是一个 <strong>编译器指令</strong>，用于防止头文件被多次包含（<strong>include</strong>）造成的重复定义问题。</p>
<p><code>#pragma once</code> 通常放在头文件的最顶部，紧挨文件开头第一行，确保在任何代码或其它 <code>#include</code> 之前。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myheader.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;other.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 下面写你的声明／定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、C-系统预定义宏"><a href="#二、C-系统预定义宏" class="headerlink" title="二、C++ 系统预定义宏"></a>二、C++ 系统预定义宏</h2><table>
<thead>
<tr>
<th>宏名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>__FILE__</code></td>
<td>当前源文件名</td>
</tr>
<tr>
<td><code>__LINE__</code></td>
<td>当前行号</td>
</tr>
<tr>
<td><code>__FUNCTION__</code></td>
<td>当前函数名（非标准）</td>
</tr>
<tr>
<td><code>__func__</code></td>
<td>当前函数名（标准C99&#x2F;C++11）</td>
</tr>
<tr>
<td><code>__DATE__</code></td>
<td>编译日期</td>
</tr>
<tr>
<td><code>__TIME__</code></td>
<td>编译时间</td>
</tr>
<tr>
<td><code>__cplusplus</code></td>
<td>是否为C++环境</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、Qt-中的宏机制"><a href="#三、Qt-中的宏机制" class="headerlink" title="三、Qt 中的宏机制"></a>三、Qt 中的宏机制</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>Qt 使用 MOC（元对象编译器）扩展 C++ 功能，宏是其核心组件之一。</p>
<h3 id="2-常用-Qt-宏"><a href="#2-常用-Qt-宏" class="headerlink" title="2. 常用 Qt 宏"></a>2. 常用 Qt 宏</h3><table>
<thead>
<tr>
<th>宏名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>Q_OBJECT</code></td>
<td>启用信号与槽、元对象系统</td>
</tr>
<tr>
<td><code>signals:</code></td>
<td>信号声明区域</td>
</tr>
<tr>
<td><code>slots:</code></td>
<td>槽函数声明区域</td>
</tr>
<tr>
<td><code>Q_PROPERTY</code></td>
<td>声明属性用于反射、QML</td>
</tr>
<tr>
<td><code>Q_ENUM</code></td>
<td>注册枚举类型</td>
</tr>
<tr>
<td><code>Q_DECLARE_METATYPE</code></td>
<td>注册类型用于 QVariant</td>
</tr>
<tr>
<td><code>Q_DISABLE_COPY</code></td>
<td>禁止拷贝构造与赋值</td>
</tr>
<tr>
<td><code>Q_ASSERT</code></td>
<td>断言调试宏</td>
</tr>
</tbody></table>
<h3 id="3-示例：信号槽类"><a href="#3-示例：信号槽类" class="headerlink" title="3. 示例：信号槽类"></a>3. 示例：信号槽类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">valueChanged</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-示例：属性定义"><a href="#4-示例：属性定义" class="headerlink" title="4. 示例：属性定义"></a>4. 示例：属性定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Q_PROPERTY(类型 名称 READ 读函数 WRITE 写函数 NOTIFY 通知信号)</span></span><br><span class="line"><span class="built_in">Q_PROPERTY</span>(<span class="type">int</span> count READ count WRITE setCount NOTIFY countChanged)</span><br><span class="line">    <span class="comment">//等价于注册一个名为 count 的 int 类型属性</span></span><br><span class="line">    <span class="comment">//绑定读取函数 int count() const</span></span><br><span class="line">    <span class="comment">//绑定写入函数 void setCount(int)</span></span><br><span class="line">    <span class="comment">//绑定信号 void countChanged()，用于通知属性值变化</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、宏替代建议"><a href="#四、宏替代建议" class="headerlink" title="四、宏替代建议"></a>四、宏替代建议</h2><table>
<thead>
<tr>
<th>功能</th>
<th>宏写法</th>
<th>替代推荐</th>
</tr>
</thead>
<tbody><tr>
<td>常量</td>
<td><code>#define PI 3.14</code></td>
<td><code>constexpr double PI = 3.14;</code></td>
</tr>
<tr>
<td>函数</td>
<td><code>#define MAX(a,b) ...</code></td>
<td><code>inline</code> 或模板函数</td>
</tr>
<tr>
<td>条件编译</td>
<td><code>#ifdef _WIN32</code></td>
<td>无替代，必须使用宏</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、Qt-宏-vs-C-宏-对比表"><a href="#五、Qt-宏-vs-C-宏-对比表" class="headerlink" title="五、Qt 宏 vs C++ 宏 对比表"></a>五、Qt 宏 vs C++ 宏 对比表</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>C++ 宏</th>
<th>Qt 宏（MOC）</th>
</tr>
</thead>
<tbody><tr>
<td>执行阶段</td>
<td>编译前文本替换</td>
<td>编译前 moc 生成 + 编译器处理</td>
</tr>
<tr>
<td>安全性</td>
<td>无类型安全，容易出错</td>
<td>类型安全，适配 Qt 系统</td>
</tr>
<tr>
<td>替换方式</td>
<td>预处理器展开</td>
<td>生成元信息支持动态行为</td>
</tr>
<tr>
<td>功能范围</td>
<td>通用文本替换、条件编译等</td>
<td>信号槽、属性、反射、QML 支持等</td>
</tr>
<tr>
<td>推荐替代</td>
<td>建议尽量用 const&#x2F;inline&#x2F;template 替代</td>
<td>必须使用 Qt 宏时必须保留</td>
</tr>
</tbody></table>
<hr>
<h2 id="六、宏使用总结技巧"><a href="#六、宏使用总结技巧" class="headerlink" title="六、宏使用总结技巧"></a>六、宏使用总结技巧</h2><ul>
<li>✅ 所有宏都必须使用 <code>#define</code></li>
<li>✅ 宏函数要加括号：参数与整个表达式</li>
<li>⚠️ 避免使用带副作用的参数如 <code>i++</code></li>
<li>✅ 使用 <code>inline</code> 替代函数宏更安全</li>
<li>✅ Qt 中必须使用 <code>Q_OBJECT</code> 启用信号槽</li>
<li>✅ 多个宏可集中写到 <code>.h</code> 文件中统一管理</li>
</ul>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 枚举类型的深入探究</title>
    <url>/2025/07/21/C++%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<blockquote>
<p>本文件就 C++ 中的枚举类型 ，作以深入的探究和了解。（总结：枚举就是整型常量集合）</p>
</blockquote>
<hr>
<h2 id="📌-一、基本定义"><a href="#📌-一、基本定义" class="headerlink" title="📌 一、基本定义"></a>📌 一、基本定义</h2><p>C++中的枚举类型（enum）是一种用户自定义的数据类型，用于表示一组具名的整型常量，可以提高代码的可读性和可维护性。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名 &#123;</span><br><span class="line">    枚举值<span class="number">1</span>,</span><br><span class="line">    枚举值<span class="number">2</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,    <span class="comment">// 默认从0开始</span></span><br><span class="line">    Green,  <span class="comment">// 1</span></span><br><span class="line">    Blue    <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="自定义起始值："><a href="#自定义起始值：" class="headerlink" title="自定义起始值："></a>自定义起始值：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green = <span class="number">3</span>,</span><br><span class="line">    Blue = <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>⚠️枚举成员是编译期常量，默认从 0 开始，可提前赋予初值，但不可运行时更改。</p>
<h3 id="枚举变量定义与使用"><a href="#枚举变量定义与使用" class="headerlink" title="枚举变量定义与使用"></a>枚举变量定义与使用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Color myColor = Green;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myColor == Green) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;It&#x27;s green!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举的本质"><a href="#枚举的本质" class="headerlink" title="枚举的本质"></a>枚举的本质</h3><p>枚举类型的每个成员在底层其实就是一个 <code>int</code> 常量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Red == <span class="number">0</span></span><br><span class="line">Green == <span class="number">1</span></span><br><span class="line">Blue == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>⚠️只可以是整形，不可以是浮点数或其它类型。</p>
<h3 id="枚举范围与冲突"><a href="#枚举范围与冲突" class="headerlink" title="枚举范围与冲突"></a>枚举范围与冲突</h3><p>同一<strong>作用域</strong>下，多个枚举可以有相同的值，但不可以有相同成员名，注意<strong>命名冲突</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Apple, Banana &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Animal</span> &#123; Dog, Cat, Apple &#125;;  <span class="comment">// ⚠️ Apple 重复定义会报错</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-二、C-11：强类型枚举（enum-class）"><a href="#✅-二、C-11：强类型枚举（enum-class）" class="headerlink" title="✅ 二、C++11：强类型枚举（enum class）"></a>✅ 二、C++11：强类型枚举（enum class）</h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><p>作用域限制：成员必须通过作用域访问（Color::Red）。</p>
</li>
<li><p>类型安全：不会隐式转换为 int，可防止类型混淆。</p>
</li>
<li><p>避免命名冲突：支持多个枚举中有相同成员名。</p>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Fruit</span> &#123; Apple, Banana &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Dog, Apple &#125;;  <span class="comment">// ✅ Apple 不冲突</span></span><br><span class="line"></span><br><span class="line">Fruit f = Fruit::Apple;</span><br><span class="line">Animal a = Animal::Apple;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="✅-三、赋值（转换）与比较（应用）"><a href="#✅-三、赋值（转换）与比较（应用）" class="headerlink" title="✅ 三、赋值（转换）与比较（应用）"></a>✅ 三、赋值（转换）与比较（应用）</h2><h3 id="枚举转换为整数："><a href="#枚举转换为整数：" class="headerlink" title="枚举转换为整数："></a>枚举转换为整数：</h3><ul>
<li>普通枚举可以直接转换：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = Red;  <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>

<ul>
<li>强类型枚举需要强制转换：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(Color::Red);  <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>

<h3 id="⚠️为枚举类型变量赋值："><a href="#⚠️为枚举类型变量赋值：" class="headerlink" title="⚠️为枚举类型变量赋值："></a>⚠️为枚举类型变量赋值：</h3><ul>
<li>❌ 不合法赋值（隐式 int → enum）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Color c = <span class="number">3</span>;  <span class="comment">// ❌ 错误，需强制转换</span></span><br></pre></td></tr></table></figure>
<ul>
<li>✅ 正确写法：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Color c = <span class="built_in">static_cast</span>&lt;Color&gt;(<span class="number">3</span>);  <span class="comment">// ✅ 正确转换方式</span></span><br></pre></td></tr></table></figure>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green = <span class="number">2</span>,</span><br><span class="line">    Blue = <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Color c = <span class="built_in">static_cast</span>&lt;Color&gt;(<span class="number">3</span>);  <span class="comment">// 将整数 3 转为 Color 类型</span></span><br><span class="line"><span class="type">int</span> x = c;                        <span class="comment">// 将枚举类型赋值给 int  ， x = 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>枚举类型变量存在的意义</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>🧠 可读性提升</td>
<td>具名常量取代数字，让代码语义明确</td>
</tr>
<tr>
<td>✅ 类型安全</td>
<td>限制只能使用定义好的状态值</td>
</tr>
<tr>
<td>🧱 结构清晰</td>
<td>定义一组固定选项，提高逻辑完整性</td>
</tr>
<tr>
<td>🚀 可维护性强</td>
<td>修改值集中在枚举处，易于管理和调试</td>
</tr>
<tr>
<td>🎯 支持工具分析</td>
<td>IDE 可以补全、跳转、检查枚举</td>
</tr>
</tbody></table>
<ul>
<li>枚举类型变量Color c 与 整型变量int c 的区别</li>
</ul>
<table>
<thead>
<tr>
<th>点</th>
<th><code>int</code></th>
<th><code>Color</code>（枚举）</th>
</tr>
</thead>
<tbody><tr>
<td>含义明确吗</td>
<td>❌ 不明确</td>
<td>✅ 具名常量，语义清晰</td>
</tr>
<tr>
<td>限制值范围吗</td>
<td>❌ 可随意赋</td>
<td>⚠️ 普通 enum 不限制；<code>enum class</code> 限制更好</td>
</tr>
<tr>
<td>类型检查</td>
<td>❌ 无类型</td>
<td>✅ 有类型检查</td>
</tr>
</tbody></table>
<p>枚举类型变量是为了让程序更像人能读懂的语言模式，本质上仍是整形变量。</p>
<h3 id="❌错误的赋值情况："><a href="#❌错误的赋值情况：" class="headerlink" title="❌错误的赋值情况："></a>❌错误的赋值情况：</h3><p>非法代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green = <span class="number">2</span>,</span><br><span class="line">    Blue = <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Color Red = <span class="number">4</span>;  <span class="comment">// ❌ 错误！</span></span><br></pre></td></tr></table></figure>
<ul>
<li>里试图声明一个变量名为 Red，而 Red 已经是一个枚举常量名。</li>
<li>用已有的常量名 Red 当变量名，属于重定义错误。</li>
</ul>
<p>类比说明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Red = <span class="number">1</span>;  <span class="comment">// 枚举常量Red的类比效果</span></span><br><span class="line"><span class="type">int</span> Red = <span class="number">4</span>;  <span class="comment">// ❌ 错误的重定义  ❌你在尝试更改const标注的常量数据❌</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚠️-四、多个枚举成员-值相同-时的行为"><a href="#⚠️-四、多个枚举成员-值相同-时的行为" class="headerlink" title="⚠️ 四、多个枚举成员  值相同  时的行为"></a>⚠️ 四、多个枚举成员  值相同  时的行为</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red = <span class="number">3</span>,</span><br><span class="line">    Green = <span class="number">3</span>,</span><br><span class="line">    Blue = <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Color c = <span class="built_in">static_cast</span>&lt;Color&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == Red) std::cout &lt;&lt; <span class="string">&quot;Red\n&quot;</span>;     <span class="comment">// ✅ true</span></span><br><span class="line"><span class="keyword">if</span> (c == Green) std::cout &lt;&lt; <span class="string">&quot;Green\n&quot;</span>; <span class="comment">// ✅ true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Red</code> 和 <code>Green</code> 值相等，无法区分是哪一个。</li>
<li><code>c</code> 只是个值为 <code>3</code> 的枚举变量，没有附带枚举名信息。</li>
<li>⚠️Color枚举内的常量名不可以相同，但是各常量的值可以相同。</li>
</ul>
<hr>
<h2 id="❗-五、浮点型赋值"><a href="#❗-五、浮点型赋值" class="headerlink" title="❗ 五、浮点型赋值"></a>❗ 五、浮点型赋值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Color c = <span class="built_in">static_cast</span>&lt;Color&gt;(<span class="number">2.5</span>);  <span class="comment">// ⚠️ 会被截断为 2，非安全行为</span></span><br></pre></td></tr></table></figure>

<p>✅ 正确写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">2.5</span>;</span><br><span class="line">Color c = <span class="built_in">static_cast</span>&lt;Color&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(f));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚠️-七、不同命名空间下的枚举类型"><a href="#⚠️-七、不同命名空间下的枚举类型" class="headerlink" title="⚠️ 七、不同命名空间下的枚举类型"></a>⚠️ 七、不同命名空间下的枚举类型</h2><p>使用不同的命名空间来定义枚举类型，可实现相同枚举常量名出现在同意作用域，且合法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Green = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Green = <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::Color a = A::Green;</span><br><span class="line">B::Fruit b = B::Green;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Green 被隔离在 A 和 B 命名空间下，互不冲突。</p>
</li>
<li><p>缺点是调用时写法较繁琐，不如 enum class 语义明确。</p>
</li>
</ul>
<hr>
<h2 id="✅-八、附加——C-中“作用域”的含义"><a href="#✅-八、附加——C-中“作用域”的含义" class="headerlink" title="✅ 八、附加——C++ 中“作用域”的含义"></a>✅ 八、附加——C++ 中“作用域”的含义</h2><p>👉 “作用域”指的是：同一命名空间、函数、类或全局块中的名字可见范围，它与“是否在同一个 .cpp &#x2F; .h 文件”或“是否在同一个线程”没有直接关系！</p>
<h3 id="🧩-示例-1：不同-cpp-文件，通过include暴露"><a href="#🧩-示例-1：不同-cpp-文件，通过include暴露" class="headerlink" title="🧩 示例 1：不同 .cpp 文件，通过include暴露"></a>🧩 示例 1：不同 .cpp 文件，通过include暴露</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// color.h</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line">Color c = Green;  <span class="comment">// ✅ 合法（Green 已泄露到全局作用域）</span></span><br></pre></td></tr></table></figure>
<p>✔️ 即使定义和使用不在同一个文件，只要通过 #include 暴露出来、且在同一个命名空间&#x2F;全局中，就属于<strong>同一作用域</strong>。</p>
<h3 id="🧩-示例-2：不同-cpp-文件，尝试冲突定义"><a href="#🧩-示例-2：不同-cpp-文件，尝试冲突定义" class="headerlink" title="🧩 示例 2：不同 .cpp 文件，尝试冲突定义"></a>🧩 示例 2：不同 .cpp 文件，尝试冲突定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// color.h</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Green = <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fruit.h</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123; Green = <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fruit.h&quot;</span>  <span class="comment">// ❌ 一旦 include 同时存在就冲突</span></span></span><br></pre></td></tr></table></figure>

<p>❌ 即便不是直接的在同一处<code>#include</code>相互暴露，而是间接产生联系，依旧会产生重定义错误。</p>
]]></content>
      <categories>
        <category>C++_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++&amp;QT常用关键词汇总</title>
    <url>/2025/07/19/C++&amp;QT%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8D%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>本文件整理了 C++和QT 中常见的各种关键词 ，方便后续回忆查阅。</p>
</blockquote>
<hr>
<h1 id="C-常用关键词整理"><a href="#C-常用关键词整理" class="headerlink" title="C++ 常用关键词整理"></a>C++ 常用关键词整理</h1><blockquote>
<p>本文整理了 C++ 编程语言中常用的关键字，按功能分类，并附有中文注释，方便快速查阅和学习。</p>
</blockquote>
<hr>
<h2 id="🧠-1-数据类型关键字"><a href="#🧠-1-数据类型关键字" class="headerlink" title="🧠 1. 数据类型关键字"></a>🧠 1. 数据类型关键字</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td>整型</td>
<td>整数类型，通常为4字节</td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度浮点型</td>
<td>有小数的数，精度较低</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度浮点型</td>
<td>精度更高的小数</td>
</tr>
<tr>
<td><code>char</code></td>
<td>字符型</td>
<td>单个字符，占1字节</td>
</tr>
<tr>
<td><code>bool</code></td>
<td>布尔类型</td>
<td>表示真（true）或假（false）</td>
</tr>
<tr>
<td><code>void</code></td>
<td>无类型</td>
<td>常用于函数不返回值</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td>宽字符类型</td>
<td>表示宽字符（支持Unicode）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔧-2-类型限定关键字"><a href="#🔧-2-类型限定关键字" class="headerlink" title="🔧 2. 类型限定关键字"></a>🔧 2. 类型限定关键字</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>用途说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>signed</code></td>
<td>有符号</td>
<td>默认，表示可以是负数</td>
</tr>
<tr>
<td><code>unsigned</code></td>
<td>无符号</td>
<td>只能是正数或0</td>
</tr>
<tr>
<td><code>short</code></td>
<td>短整型</td>
<td>通常占2字节</td>
</tr>
<tr>
<td><code>long</code></td>
<td>长整型</td>
<td>占用更大内存</td>
</tr>
<tr>
<td><code>const</code></td>
<td>常量</td>
<td>表示值不可改变</td>
</tr>
<tr>
<td><code>static</code></td>
<td>静态</td>
<td>在函数内变量保持值，在类中为共享变量</td>
</tr>
<tr>
<td><code>mutable</code></td>
<td>可变</td>
<td>即使在const对象中也能改变的成员</td>
</tr>
<tr>
<td><code>volatile</code></td>
<td>易变</td>
<td>表示变量可能被意外修改（多线程&#x2F;硬件）</td>
</tr>
<tr>
<td><code>extern</code></td>
<td>外部引用</td>
<td>表示变量或函数定义在别处</td>
</tr>
<tr>
<td><code>register</code></td>
<td>寄存器建议</td>
<td>建议将变量存储在CPU寄存器中（现代已无效）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧱-3-控制结构关键字"><a href="#🧱-3-控制结构关键字" class="headerlink" title="🧱 3. 控制结构关键字"></a>🧱 3. 控制结构关键字</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>用途说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>if</code></td>
<td>条件语句</td>
<td>条件判断</td>
</tr>
<tr>
<td><code>else</code></td>
<td>否则</td>
<td>与if搭配</td>
</tr>
<tr>
<td><code>switch</code></td>
<td>多分支选择</td>
<td>适合多个case判断</td>
</tr>
<tr>
<td><code>case</code></td>
<td>分支情况</td>
<td>switch中的子项</td>
</tr>
<tr>
<td><code>default</code></td>
<td>默认分支</td>
<td>switch中未匹配的情况</td>
</tr>
<tr>
<td><code>while</code></td>
<td>当…时循环</td>
<td>条件为真则一直循环</td>
</tr>
<tr>
<td><code>do</code></td>
<td>执行</td>
<td>先执行一次再判断条件</td>
</tr>
<tr>
<td><code>for</code></td>
<td>循环</td>
<td>常用于计数循环</td>
</tr>
<tr>
<td><code>break</code></td>
<td>跳出</td>
<td>跳出循环或switch</td>
</tr>
<tr>
<td><code>continue</code></td>
<td>跳过</td>
<td>跳过当前循环，进入下次</td>
</tr>
<tr>
<td><code>goto</code></td>
<td>跳转</td>
<td>跳转到指定标签（不推荐使用）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧵-4-类和对象关键字"><a href="#🧵-4-类和对象关键字" class="headerlink" title="🧵 4. 类和对象关键字"></a>🧵 4. 类和对象关键字</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>用途说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>class</code></td>
<td>类</td>
<td>定义类</td>
</tr>
<tr>
<td><code>struct</code></td>
<td>结构体</td>
<td>与class类似，默认public</td>
</tr>
<tr>
<td><code>union</code></td>
<td>联合体</td>
<td>成员共享内存</td>
</tr>
<tr>
<td><code>enum</code></td>
<td>枚举类型</td>
<td>定义有限个数值的类型</td>
</tr>
<tr>
<td><code>private</code></td>
<td>私有成员</td>
<td>类中只能内部访问</td>
</tr>
<tr>
<td><code>public</code></td>
<td>公有成员</td>
<td>可被外部访问</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>受保护成员</td>
<td>类及子类可访问</td>
</tr>
<tr>
<td><code>this</code></td>
<td>当前对象指针</td>
<td>指向当前类实例</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔁-5-函数与内存关键字"><a href="#🔁-5-函数与内存关键字" class="headerlink" title="🔁 5. 函数与内存关键字"></a>🔁 5. 函数与内存关键字</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>用途说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>return</code></td>
<td>返回</td>
<td>从函数返回值</td>
</tr>
<tr>
<td><code>new</code></td>
<td>创建新对象</td>
<td>动态分配内存</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>删除对象</td>
<td>释放动态分配的内存</td>
</tr>
<tr>
<td><code>sizeof</code></td>
<td>大小</td>
<td>计算变量或类型占用字节数</td>
</tr>
</tbody></table>
<hr>
<h2 id="🚀-6-继承与多态关键字"><a href="#🚀-6-继承与多态关键字" class="headerlink" title="🚀 6. 继承与多态关键字"></a>🚀 6. 继承与多态关键字</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>用途说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>virtual</code></td>
<td>虚函数</td>
<td>用于多态</td>
</tr>
<tr>
<td><code>override</code></td>
<td>重写</td>
<td>明确标记重写基类方法</td>
</tr>
<tr>
<td><code>final</code></td>
<td>最终</td>
<td>防止派生类再重写</td>
</tr>
<tr>
<td><code>explicit</code></td>
<td>显式</td>
<td>防止构造函数隐式转换</td>
</tr>
<tr>
<td><code>friend</code></td>
<td>友元</td>
<td>允许非类成员访问私有数据</td>
</tr>
<tr>
<td><code>inline</code></td>
<td>内联</td>
<td>编译器将函数代码嵌入调用处</td>
</tr>
<tr>
<td><code>operator</code></td>
<td>运算符重载</td>
<td>定义自定义运算符行为</td>
</tr>
<tr>
<td><code>template</code></td>
<td>模板</td>
<td>泛型编程的核心关键字</td>
</tr>
</tbody></table>
<hr>
<h2 id="⚙️-7-异常处理关键字"><a href="#⚙️-7-异常处理关键字" class="headerlink" title="⚙️ 7. 异常处理关键字"></a>⚙️ 7. 异常处理关键字</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>用途说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>try</code></td>
<td>尝试块</td>
<td>捕获可能抛出异常的代码</td>
</tr>
<tr>
<td><code>catch</code></td>
<td>捕获块</td>
<td>捕获并处理异常</td>
</tr>
<tr>
<td><code>throw</code></td>
<td>抛出异常</td>
<td>抛出异常对象</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧪-8-命名空间与模块"><a href="#🧪-8-命名空间与模块" class="headerlink" title="🧪 8. 命名空间与模块"></a>🧪 8. 命名空间与模块</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>用途说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>namespace</code></td>
<td>命名空间</td>
<td>避免名称冲突</td>
</tr>
<tr>
<td><code>using</code></td>
<td>使用</td>
<td>引入命名空间或类型</td>
</tr>
<tr>
<td><code>decltype</code></td>
<td>推导类型</td>
<td>获取表达式的类型</td>
</tr>
<tr>
<td><code>typeid</code></td>
<td>类型信息</td>
<td>获取运行时类型（需 <code>#include &lt;typeinfo&gt;</code>）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧪-9-C-11-14-17-20-新增关键字（常用）"><a href="#🧪-9-C-11-14-17-20-新增关键字（常用）" class="headerlink" title="🧪 9. C++11&#x2F;14&#x2F;17&#x2F;20 新增关键字（常用）"></a>🧪 9. C++11&#x2F;14&#x2F;17&#x2F;20 新增关键字（常用）</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>自动类型推导</td>
<td>编译器自动判断类型</td>
</tr>
<tr>
<td><code>nullptr</code></td>
<td>空指针常量</td>
<td>替代NULL</td>
</tr>
<tr>
<td><code>constexpr</code></td>
<td>编译期常量函数</td>
<td>在编译时求值的函数</td>
</tr>
<tr>
<td><code>noexcept</code></td>
<td>不抛异常声明</td>
<td>用于优化</td>
</tr>
<tr>
<td><code>static_assert</code></td>
<td>静态断言</td>
<td>编译期间校验条件</td>
</tr>
<tr>
<td><code>concept</code></td>
<td>概念（C++20）</td>
<td>模板约束规则</td>
</tr>
<tr>
<td><code>co_await</code> <code>co_yield</code> <code>co_return</code></td>
<td>协程（C++20）</td>
<td>实现异步协程机制</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>如果你有进一步需求，如添加 STL、标准库函数、运算符重载表等，也可以继续告诉我，我可以持续补充。</p>
</blockquote>
<hr>
<h1 id="Qt-常用关键词整理"><a href="#Qt-常用关键词整理" class="headerlink" title="Qt 常用关键词整理"></a>Qt 常用关键词整理</h1><h2 id="🔷-Qt-核心模块关键词"><a href="#🔷-Qt-核心模块关键词" class="headerlink" title="🔷 Qt 核心模块关键词"></a>🔷 Qt 核心模块关键词</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>QObject</code></td>
<td>Qt对象基类</td>
<td>所有Qt对象的基类，支持信号槽机制</td>
</tr>
<tr>
<td><code>QWidget</code></td>
<td>窗口部件基类</td>
<td>所有可视控件的基类</td>
</tr>
<tr>
<td><code>QApplication</code></td>
<td>应用程序对象</td>
<td>管理GUI控制流和主要设置</td>
</tr>
<tr>
<td><code>QMainWindow</code></td>
<td>主窗口类</td>
<td>有菜单栏、工具栏、状态栏的窗口</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔗-信号与槽机制相关关键词"><a href="#🔗-信号与槽机制相关关键词" class="headerlink" title="🔗 信号与槽机制相关关键词"></a>🔗 信号与槽机制相关关键词</h2><table>
<thead>
<tr>
<th>关键词</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>signals</code></td>
<td>信号定义</td>
<td>声明一个信号</td>
</tr>
<tr>
<td><code>slots</code></td>
<td>槽函数定义</td>
<td>声明一个槽函数</td>
</tr>
<tr>
<td><code>emit</code></td>
<td>发射信号</td>
<td>发出一个信号</td>
</tr>
<tr>
<td><code>connect</code></td>
<td>连接</td>
<td>将信号与槽连接起来</td>
</tr>
<tr>
<td><code>disconnect</code></td>
<td>断开连接</td>
<td>信号与槽断开</td>
</tr>
</tbody></table>
<hr>
<h2 id="🎨-常用控件类"><a href="#🎨-常用控件类" class="headerlink" title="🎨 常用控件类"></a>🎨 常用控件类</h2><table>
<thead>
<tr>
<th>控件类</th>
<th>中文含义</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>QPushButton</code></td>
<td>按钮控件</td>
<td>常用按钮</td>
</tr>
<tr>
<td><code>QLabel</code></td>
<td>标签控件</td>
<td>显示文本或图像</td>
</tr>
<tr>
<td><code>QLineEdit</code></td>
<td>单行文本框</td>
<td>输入框</td>
</tr>
<tr>
<td><code>QTextEdit</code></td>
<td>多行文本框</td>
<td>多行输入</td>
</tr>
<tr>
<td><code>QCheckBox</code></td>
<td>复选框</td>
<td>多选功能</td>
</tr>
<tr>
<td><code>QRadioButton</code></td>
<td>单选框</td>
<td>单选功能</td>
</tr>
<tr>
<td><code>QComboBox</code></td>
<td>下拉框</td>
<td>选择框</td>
</tr>
<tr>
<td><code>QListWidget</code></td>
<td>列表控件</td>
<td>显示列表项</td>
</tr>
<tr>
<td><code>QTableWidget</code></td>
<td>表格控件</td>
<td>显示表格内容</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧵-线程与异步"><a href="#🧵-线程与异步" class="headerlink" title="🧵 线程与异步"></a>🧵 线程与异步</h2><table>
<thead>
<tr>
<th>类名 &#x2F; 关键字</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>QThread</code></td>
<td>线程类</td>
<td>实现多线程</td>
</tr>
<tr>
<td><code>QRunnable</code></td>
<td>可运行任务</td>
<td>配合线程池使用</td>
</tr>
<tr>
<td><code>QThreadPool</code></td>
<td>线程池</td>
<td>管理任务并发执行</td>
</tr>
<tr>
<td><code>Qt::QueuedConnection</code></td>
<td>排队连接</td>
<td>信号跨线程自动排队处理</td>
</tr>
<tr>
<td><code>moveToThread()</code></td>
<td>移动线程</td>
<td>将对象移动到指定线程执行</td>
</tr>
</tbody></table>
<hr>
<h2 id="⏰-事件与定时器"><a href="#⏰-事件与定时器" class="headerlink" title="⏰ 事件与定时器"></a>⏰ 事件与定时器</h2><table>
<thead>
<tr>
<th>关键词 &#x2F; 类名</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>event()</code></td>
<td>事件处理函数</td>
<td>处理通用事件</td>
</tr>
<tr>
<td><code>QEvent</code></td>
<td>事件类</td>
<td>所有事件的基类</td>
</tr>
<tr>
<td><code>QTimer</code></td>
<td>定时器</td>
<td>定时触发信号</td>
</tr>
<tr>
<td><code>timerEvent()</code></td>
<td>定时事件处理</td>
<td>处理定时器事件</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧩-布局管理与绘图"><a href="#🧩-布局管理与绘图" class="headerlink" title="🧩 布局管理与绘图"></a>🧩 布局管理与绘图</h2><table>
<thead>
<tr>
<th>类名 &#x2F; 关键字</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>QVBoxLayout</code></td>
<td>垂直布局</td>
<td>控件垂直排列</td>
</tr>
<tr>
<td><code>QHBoxLayout</code></td>
<td>水平布局</td>
<td>控件水平排列</td>
</tr>
<tr>
<td><code>QGridLayout</code></td>
<td>网格布局</td>
<td>控件按格子排布</td>
</tr>
<tr>
<td><code>paintEvent()</code></td>
<td>绘图事件</td>
<td>绘图时重写的函数</td>
</tr>
<tr>
<td><code>QPainter</code></td>
<td>绘图工具</td>
<td>用于2D绘图</td>
</tr>
<tr>
<td><code>QPen</code> &#x2F; <code>QBrush</code></td>
<td>画笔&#x2F;画刷</td>
<td>控制绘图样式</td>
</tr>
</tbody></table>
<hr>
<h2 id="🌐-网络与IO"><a href="#🌐-网络与IO" class="headerlink" title="🌐 网络与IO"></a>🌐 网络与IO</h2><table>
<thead>
<tr>
<th>类名</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>QTcpSocket</code></td>
<td>TCP 套接字</td>
<td>用于TCP通信</td>
</tr>
<tr>
<td><code>QTcpServer</code></td>
<td>TCP服务器</td>
<td>监听连接</td>
</tr>
<tr>
<td><code>QUdpSocket</code></td>
<td>UDP套接字</td>
<td>无连接的数据通信</td>
</tr>
<tr>
<td><code>QFile</code></td>
<td>文件读写类</td>
<td>读写文件内容</td>
</tr>
<tr>
<td><code>QTextStream</code></td>
<td>文本流</td>
<td>操作文本格式数据</td>
</tr>
<tr>
<td><code>QDataStream</code></td>
<td>数据流</td>
<td>操作二进制格式数据</td>
</tr>
</tbody></table>
<hr>
<h2 id="📁-文件与路径"><a href="#📁-文件与路径" class="headerlink" title="📁 文件与路径"></a>📁 文件与路径</h2><table>
<thead>
<tr>
<th>类名</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>QDir</code></td>
<td>目录类</td>
<td>文件夹操作</td>
</tr>
<tr>
<td><code>QFileInfo</code></td>
<td>文件信息</td>
<td>提取路径、大小等</td>
</tr>
<tr>
<td><code>QStandardPaths</code></td>
<td>标准路径</td>
<td>获取用户桌面、文档等系统路径</td>
</tr>
</tbody></table>
<hr>
<h2 id="🛠️-其他常用类-宏"><a href="#🛠️-其他常用类-宏" class="headerlink" title="🛠️ 其他常用类&#x2F;宏"></a>🛠️ 其他常用类&#x2F;宏</h2><table>
<thead>
<tr>
<th>名称</th>
<th>中文含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>QVariant</code></td>
<td>通用类型</td>
<td>可保存任意类型值</td>
</tr>
<tr>
<td><code>QMap</code> &#x2F; <code>QHash</code></td>
<td>映射容器</td>
<td>键值对容器</td>
</tr>
<tr>
<td><code>QString</code></td>
<td>字符串类</td>
<td>Unicode字符串</td>
</tr>
<tr>
<td><code>QDebug</code></td>
<td>调试输出</td>
<td>用于打印调试信息</td>
</tr>
<tr>
<td><code>Q_PROPERTY</code></td>
<td>属性宏</td>
<td>用于QML绑定或反射</td>
</tr>
<tr>
<td><code>Q_OBJECT</code></td>
<td>元对象宏</td>
<td>启用信号槽与元信息系统</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 项目创建与本地同步管理</title>
    <url>/2025/02/18/GitHub%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>本文记录如何将创建 GitHub 仓库，并进行本地同步与管理。</p>
</blockquote>
<hr>
<h2 id="🔧-准备工具"><a href="#🔧-准备工具" class="headerlink" title="🔧 准备工具"></a>🔧 准备工具</h2><p>在开始前，请确认你已具备以下工具环境：</p>
<ul>
<li><p>✅ 已注册 <a href="https://github.com/">GitHub</a> 账号</p>
</li>
<li><p>✅ 已安装 Git 工具（推荐安装 <a href="https://git-scm.com/download/win">Git for Windows</a>）</p>
</li>
<li><p>✅ 已安装 nodejs（推荐安装 <a href="https://nodejs.org/en/">nodejs</a>）(<a href="https://www.cnblogs.com/liuqiyun/p/8133904.html">Node.js安装及环境配置之Windows篇</a>)</p>
</li>
<li><p>✅ 管理员运行cmd，依次输入,完成环境验证</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v（node安装后附带）</span><br><span class="line">git -v</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="一、GitHub-创建新仓库"><a href="#一、GitHub-创建新仓库" class="headerlink" title="一、GitHub 创建新仓库"></a>一、GitHub 创建新仓库</h2><ol>
<li><p>登录 <a href="https://github.com/">GitHub</a></p>
</li>
<li><p>点击右上角 → <code>New repository</code></p>
</li>
<li><p>仓库名称填：<code>myProject</code></p>
</li>
<li><p>不勾选 <code>Initialize with a README</code>（保持为空仓库）</p>
</li>
<li><p>创建成功后会看到仓库地址：<br><code>https://github.com/GithubUserName/myGithubProject.git</code></p>
</li>
</ol>
<hr>
<h2 id="二、本地初始化-Git-项目并上传"><a href="#二、本地初始化-Git-项目并上传" class="headerlink" title="二、本地初始化 Git 项目并上传"></a>二、本地初始化 Git 项目并上传</h2><h3 id="在-Git-Bash-执行以下命令："><a href="#在-Git-Bash-执行以下命令：" class="headerlink" title="在 Git Bash 执行以下命令："></a>在 Git Bash 执行以下命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /项目本地存储的地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Git 仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 README 文件（可选）(GitHub创建新仓库若勾选Initialize with a README无需该项)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# myGithubProject&quot;</span> &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部文件添加到 Git 缓存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到本地仓库，并为该次提交添加备注</span></span><br><span class="line">git commit -m <span class="string">&quot;初始化GitHub项目&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认分支为 main</span></span><br><span class="line">git branch -M main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库地址（SSH 方式）(需先为本机配置ssh密钥)</span></span><br><span class="line">git remote add origin git@github.com:GithubUserName/myGithubProject.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到 GitHub（第一次）</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、配置-SSH-密钥（推荐）"><a href="#三、配置-SSH-密钥（推荐）" class="headerlink" title="三、配置 SSH 密钥（推荐）"></a>三、配置 SSH 密钥（推荐）</h2><p>避免每次 push 都输入密码，建议使用 SSH：</p>
<h3 id="1-检查是否已有密钥："><a href="#1-检查是否已有密钥：" class="headerlink" title="1. 检查是否已有密钥："></a>1. 检查是否已有密钥：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如有 <code>id_rsa</code> 和 <code>id_rsa.pub</code>，可跳过生成步骤。</p>
<h3 id="2-生成新密钥（如无）："><a href="#2-生成新密钥（如无）：" class="headerlink" title="2. 生成新密钥（如无）："></a>2. 生成新密钥（如无）：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮箱地址&quot;</span></span><br></pre></td></tr></table></figure>

<p>一路回车生成。</p>
<h3 id="3-添加到-GitHub："><a href="#3-添加到-GitHub：" class="headerlink" title="3. 添加到 GitHub："></a>3. 添加到 GitHub：</h3><ul>
<li>打开 GitHub → Settings → SSH and GPG Keys → New SSH Key</li>
<li>将 <code>C:\Users\用户名\ .ssh/id_rsa.pub</code> 内容复制粘贴进去</li>
</ul>
<h3 id="4-测试连接是否成功："><a href="#4-测试连接是否成功：" class="headerlink" title="4. 测试连接是否成功："></a>4. 测试连接是否成功：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>输出成功即配置完成。</p>
<hr>
<h2 id="四、后续上传资源流程"><a href="#四、后续上传资源流程" class="headerlink" title="四、后续上传资源流程"></a>四、后续上传资源流程</h2><p>每次更新本地资源，只需执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;更新说明&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、可选：添加-gitignore-文件"><a href="#五、可选：添加-gitignore-文件" class="headerlink" title="五、可选：添加 .gitignore 文件"></a>五、可选：添加 .gitignore 文件</h2><p>为避免上传无用文件，可添加 <code>.gitignore</code> 文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.<span class="built_in">log</span>           <span class="comment"># 忽略所有 .log 结尾的日志文件</span></span><br><span class="line">node_modules/   <span class="comment"># 忽略 node_modules 目录（前端项目常用）</span></span><br><span class="line">.DS_Store       <span class="comment"># 忽略 macOS 系统的临时文件</span></span><br><span class="line">Thumbs.db       <span class="comment"># 忽略 Windows 系统缩略图缓存</span></span><br><span class="line">*.tmp           <span class="comment"># 忽略所有 .tmp 临时文件</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-小贴士"><a href="#✅-小贴士" class="headerlink" title="✅ 小贴士"></a>✅ 小贴士</h2><ul>
<li><p>GitHub 上文件比本地多时，先执行：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --rebase origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看远程仓库地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看提交历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>以上就是完整的GitHub项目创建与管理流程</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt项目在Android系统环境下实现开机自启</title>
    <url>/2025/03/04/Qt%20for%20Android%20%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</url>
    <content><![CDATA[<blockquote>
<p>本文记录如何在 Qt for Android 项目中，实现应用 <strong>随系统开机自动启动</strong> 的功能，适用于设备控制、工控系统等常驻应用场景。</p>
</blockquote>
<hr>
<h2 id="🧩-实现思路概述"><a href="#🧩-实现思路概述" class="headerlink" title="🧩 实现思路概述"></a>🧩 实现思路概述</h2><ol>
<li><strong>新建一个 <code>BroadcastReceiver</code> 类</strong>，用于监听系统开机广播（<code>BOOT_COMPLETED</code>）。</li>
<li><strong>接收到广播后，启动主界面 <code>JBmsActivity</code></strong>，它继承自 <code>QtActivity</code>，自动调用 Qt C++ 层的 <code>main()</code> 函数。</li>
<li><strong>在 <code>AndroidManifest.xml</code> 中声明权限和注册广播接收器</strong>。</li>
</ol>
<hr>
<h2 id="✅-步骤一：新建-BootReceiver-java（监听开机广播）"><a href="#✅-步骤一：新建-BootReceiver-java（监听开机广播）" class="headerlink" title="✅ 步骤一：新建 BootReceiver.java（监听开机广播）"></a>✅ 步骤一：新建 BootReceiver.java（监听开机广播）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.qtproject.example.activityhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播接收器类，用于监听 BOOT_COMPLETED 广播（开机完成）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 Qt 主界面（JBmsActivity）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startApp</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;BootReceiver&quot;</span>, <span class="string">&quot;启动QT应用&quot;</span>);</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">splashIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(context, JBmsActivity.class);</span><br><span class="line">        splashIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <span class="comment">// 必须设置此标志，否则会抛异常</span></span><br><span class="line">        context.startActivity(splashIntent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收广播事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) &#123;</span><br><span class="line">            startApp(context, intent); <span class="comment">// 收到系统广播后启动应用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-步骤二：创建-Qt-启动-Activity（JBmsActivity）"><a href="#✅-步骤二：创建-Qt-启动-Activity（JBmsActivity）" class="headerlink" title="✅ 步骤二：创建 Qt 启动 Activity（JBmsActivity）"></a>✅ 步骤二：创建 Qt 启动 Activity（JBmsActivity）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.qtproject.example.activityhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> org.qtproject.qt5.android.bindings.QtActivity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JBmsActivity 是 Qt 的启动 Activity，继承 QtActivity 后会触发 Qt 的 main()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JBmsActivity</span> <span class="keyword">extends</span> <span class="title class_">QtActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;JBmsActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否拥有悬浮窗权限（部分国产系统需要）</span></span><br><span class="line">        <span class="keyword">if</span> (!Settings.canDrawOverlays(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">            intent.setData(Uri.parse(<span class="string">&quot;package:&quot;</span> + getPackageName()));</span><br><span class="line">            startActivityForResult(intent, <span class="number">0</span>); <span class="comment">// 请求权限</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hideBottomUIMenu(); <span class="comment">// 设置全屏沉浸式模式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面恢复时重新隐藏虚拟按键</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        hideBottomUIMenu();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置沉浸式全屏，隐藏底部导航栏</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hideBottomUIMenu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> flags;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            flags = View.SYSTEM_UI_FLAG_FULLSCREEN</span><br><span class="line">                    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</span><br><span class="line">                    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</span><br><span class="line">                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">                    | View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br><span class="line">                    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flags = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</span><br><span class="line">                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;</span><br><span class="line">        &#125;</span><br><span class="line">        getWindow().getDecorView().setSystemUiVisibility(flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收权限申请结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == <span class="number">0</span> &amp;&amp; Settings.canDrawOverlays(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;悬浮窗权限已授权&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-步骤三：AndroidManifest-xml-配置"><a href="#✅-步骤三：AndroidManifest-xml-配置" class="headerlink" title="✅ 步骤三：AndroidManifest.xml 配置"></a>✅ 步骤三：AndroidManifest.xml 配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;org.qtproject.example.activityhandler&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开机广播权限 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 悬浮窗权限 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Qt 启动 Activity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.JBmsActivity&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:label</span>=<span class="string">&quot;My Qt App&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:configChanges</span>=<span class="string">&quot;orientation|screenSize|keyboardHidden&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTop&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:theme</span>=<span class="string">&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 启动广播监听器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.BootReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:permission</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧠-启动流程图（简述）"><a href="#🧠-启动流程图（简述）" class="headerlink" title="🧠 启动流程图（简述）"></a>🧠 启动流程图（简述）</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">设备开机</span><br><span class="line">  ↓</span><br><span class="line">发送 BOOT_COMPLETED 广播</span><br><span class="line">  ↓</span><br><span class="line">BootReceiver 接收 → 启动 JBmsActivity</span><br><span class="line">  ↓</span><br><span class="line">JBmsActivity 继承 QtActivity → 自动启动 Qt 的 main()</span><br><span class="line">  ↓</span><br><span class="line">Qt 应用开始运行</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-注意事项"><a href="#✅-注意事项" class="headerlink" title="✅ 注意事项"></a>✅ 注意事项</h2><ul>
<li>Android 8.0+ 要求：应用必须 <strong>手动启动过一次</strong> 才能接收 BOOT_COMPLETED</li>
<li>悬浮窗权限属于特殊权限，用户必须手动授权</li>
<li>在国产 ROM 中可能还需手动加入“自启白名单”</li>
</ul>
<hr>
<p>本文适用于基于 Qt 5&#x2F;6 的 Android 项目，如需搭配 JNI 与原生服务还可扩展 Service 保活策略。</p>
<hr>
<h2 id="🧠-JBmsActivity-就是-Android-下的-Qt-启动“main-函数入口”"><a href="#🧠-JBmsActivity-就是-Android-下的-Qt-启动“main-函数入口”" class="headerlink" title="🧠 JBmsActivity 就是 Android 下的 Qt 启动“main 函数入口”"></a>🧠 JBmsActivity 就是 Android 下的 Qt 启动“main 函数入口”</h2><p>在桌面 Qt 应用中，我们通常通过 <code>main()</code> 函数作为程序入口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在 Android 平台，Qt 应用无法直接从 <code>main()</code> 启动，而是依赖 Android 的启动机制：</p>
<table>
<thead>
<tr>
<th>桌面 Qt</th>
<th>Android Qt</th>
</tr>
</thead>
<tbody><tr>
<td>直接运行 <code>main()</code></td>
<td>系统启动 <code>JBmsActivity</code></td>
</tr>
<tr>
<td><code>main()</code> 由开发者控制</td>
<td><code>main()</code> 被 QtActivity 通过 JNI 间接调用</td>
</tr>
<tr>
<td>生命周期在 C++ 控制</td>
<td>生命周期由 Java 层控制，可 hook 各阶段逻辑</td>
</tr>
</tbody></table>
<p>因此，<code>JBmsActivity</code>：</p>
<ul>
<li>是系统启动 Qt 的第一站；</li>
<li>可以用来检查权限、加载配置；</li>
<li>可以控制是否进入 Qt 主程序；</li>
<li>是控制整个程序生命周期的重要位置；</li>
<li>类似“Android 环境下的 main 函数守门人”。</li>
</ul>
<p>你也可以选择在 <code>JBmsActivity</code> 里根据业务逻辑决定：</p>
<ul>
<li>是否直接启动 Qt；</li>
<li>延迟进入 Qt；</li>
<li>或者根本不进入 Qt，仅运行 Java 层逻辑。</li>
</ul>
<p>这使得 <code>JBmsActivity</code> 成为 Android Qt 项目的关键入口点。</p>
]]></content>
      <categories>
        <category>QT实例</category>
      </categories>
      <tags>
        <tag>QT for Android</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客部署 GitHub 失败解决方案</title>
    <url>/2025/03/25/hexo_github_%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>Hexo 博客部署 GitHub Pages 出现 无法更新 甚至404错误 的完整排查与修复记录（含 .nojekyll + Actions 冲突）</p>
</blockquote>
<hr>
<h2 id="📌-背景"><a href="#📌-背景" class="headerlink" title="📌 背景"></a>📌 背景</h2><p>在使用 Hexo 部署静态博客到 GitHub Pages 的过程中，虽然本地 <code>hexo g &amp;&amp; hexo d</code> 执行成功，但访问 <code>https://用户名.github.io/</code> 却发现没有更新，甚至出现 404 错误。</p>
<hr>
<h2 id="💥-遇到的问题"><a href="#💥-遇到的问题" class="headerlink" title="💥 遇到的问题"></a>💥 遇到的问题</h2><h3 id="❌-GitHub-Actions-自动部署失败"><a href="#❌-GitHub-Actions-自动部署失败" class="headerlink" title="❌ GitHub Actions 自动部署失败"></a>❌ GitHub Actions 自动部署失败</h3><p>错误如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Error: Getting Pages deployment status failed</span><br><span class="line">Error: HttpError: Server Error</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧨-问题症状"><a href="#🧨-问题症状" class="headerlink" title="🧨 问题症状"></a>🧨 问题症状</h2><ul>
<li>页面提示：<code>404 - There isn&#39;t a GitHub Pages site here.</code></li>
<li>GitHub Actions 中的 <code>pages-build-deployment</code> 多次失败</li>
<li>GitHub Pages 设置正确，使用的是 <code>main</code> 分支 + <code>/ (root)</code></li>
<li>本地 Hexo 部署成功，<code>public/</code> 目录文件也正常生成</li>
</ul>
<hr>
<h2 id="🧠-问题原因总结"><a href="#🧠-问题原因总结" class="headerlink" title="🧠 问题原因总结"></a>🧠 问题原因总结</h2><h3 id="✅-问题-1：GitHub-默认使用-Jekyll-构建"><a href="#✅-问题-1：GitHub-默认使用-Jekyll-构建" class="headerlink" title="✅ 问题 1：GitHub 默认使用 Jekyll 构建"></a>✅ 问题 1：GitHub 默认使用 Jekyll 构建</h3><p>Hexo 是静态文件，不需要 Jekyll。但 GitHub 默认认为你的站点是用 Jekyll 构建的，导致：</p>
<ul>
<li>部分页面不停的构建失败</li>
<li>原因未知，部分页面可以完成构建，部分将失败，这部分是失败的构建将使当此部署失败</li>
</ul>
<hr>
<h2 id="✅-解决方案步骤"><a href="#✅-解决方案步骤" class="headerlink" title="✅ 解决方案步骤"></a>✅ 解决方案步骤</h2><h3 id="🔧-步骤-1：创建-nojekyll-文件"><a href="#🔧-步骤-1：创建-nojekyll-文件" class="headerlink" title="🔧 步骤 1：创建 .nojekyll 文件"></a>🔧 步骤 1：创建 <code>.nojekyll</code> 文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> &gt; <span class="built_in">source</span>/.nojekyll</span><br></pre></td></tr></table></figure>

<p>或者在 <code>source/</code> 目录下手动新建一个 <code>.nojekyll</code> 空文件。</p>
<p>该文件为空白文件，意思为声明该目录不需要github进行Jekyll 构建。</p>
<hr>
<h3 id="🔧-步骤-2：配置-Hexo-自动包含-nojekyll"><a href="#🔧-步骤-2：配置-Hexo-自动包含-nojekyll" class="headerlink" title="🔧 步骤 2：配置 Hexo 自动包含 .nojekyll"></a>🔧 步骤 2：配置 Hexo 自动包含 <code>.nojekyll</code></h3><p>打开 Hexo 根目录下的 <code>_config.yml</code>，添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">.nojekyll</span></span><br></pre></td></tr></table></figure>

<p>这一步非常关键！它能让 Hexo 构建时自动将 <code>.nojekyll</code> 拷贝进 <code>public/</code> 目录。</p>
<hr>
<h3 id="🔧-步骤-3：重新构建并部署"><a href="#🔧-步骤-3：重新构建并部署" class="headerlink" title="🔧 步骤 3：重新构建并部署"></a>🔧 步骤 3：重新构建并部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<hr>
<p>- </p>
<hr>
<h2 id="✅-最终效果"><a href="#✅-最终效果" class="headerlink" title="✅ 最终效果"></a>✅ 最终效果</h2><ul>
<li><code>https://用户名.github.io/</code> 正常加载页面</li>
<li>GitHub Pages 不再报错</li>
<li>所有 Hexo 静态资源都被正确部署并可访问</li>
</ul>
<hr>
<h2 id="✨-总结"><a href="#✨-总结" class="headerlink" title="✨ 总结"></a>✨ 总结</h2><table>
<thead>
<tr>
<th>配置项</th>
<th>是否完成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.nojekyll</code> 文件</td>
<td>✅</td>
<td>禁用 Jekyll</td>
</tr>
<tr>
<td><code>include:</code> 配置</td>
<td>✅</td>
<td>确保 <code>.nojekyll</code> 被打包到 public</td>
</tr>
<tr>
<td>Pages 源设置</td>
<td>✅</td>
<td>main 分支 + &#x2F; 根目录</td>
</tr>
</tbody></table>
<hr>
<p>🚀 <strong>部署成功的关键在于 <code>.nojekyll + include 配置</code>，一旦设置完毕，即可跳过所有 Jekyll 和 Actions 的构建干扰。</strong></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>qmake CMake 项目配置分析</title>
    <url>/2025/03/17/qmake_cmake%20%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>QT两种配置文件qmake和CMake的对比分析与总结，以及qmake详细配置示例</p>
</blockquote>
<hr>
<h2 id="1-定位与设计背景"><a href="#1-定位与设计背景" class="headerlink" title="1. 定位与设计背景"></a>1. 定位与设计背景</h2><ul>
<li><p><strong>qmake</strong>  </p>
<ul>
<li>专为 Qt 量身打造的构建工具，简化 Qt 项目的构建流程。</li>
<li>自动处理 <code>.pro</code> 文件，生成 Makefile 或 IDE 工程，深度集成 moc、uic、rcc 等 Qt 工具。</li>
</ul>
</li>
<li><p><strong>CMake</strong>  </p>
<ul>
<li>通用的跨平台构建系统，独立于 Qt 生态，由 Kitware 开发。</li>
<li>支持生成多个平台下的工程文件（Makefile、Ninja、Visual Studio、Xcode 等）。</li>
</ul>
</li>
</ul>
<h2 id="2-语法与配置方式"><a href="#2-语法与配置方式" class="headerlink" title="2. 语法与配置方式"></a>2. 语法与配置方式</h2><table>
<thead>
<tr>
<th>比较维度</th>
<th>qmake</th>
<th>CMake</th>
</tr>
</thead>
<tbody><tr>
<td>配置文件</td>
<td><code>.pro</code></td>
<td><code>CMakeLists.txt</code></td>
</tr>
<tr>
<td>语法风格</td>
<td>键值对式，声明式（简洁）</td>
<td>命令式，功能丰富但较复杂</td>
</tr>
<tr>
<td>特性支持</td>
<td>默认处理 Qt 特性（moc&#x2F;uic&#x2F;rcc）</td>
<td>需显式调用相关宏如 <code>QT_WRAP_CPP</code> 等</td>
</tr>
</tbody></table>
<h2 id="3-构建目录管理"><a href="#3-构建目录管理" class="headerlink" title="3. 构建目录管理"></a>3. 构建目录管理</h2><ul>
<li><p><strong>qmake</strong>  </p>
<ul>
<li>默认在源码树中生成 Makefile，也支持 shadow build（Qt Creator 支持）。</li>
</ul>
</li>
<li><p><strong>CMake</strong>  </p>
<ul>
<li>天然支持源码树外构建（out-of-source），便于管理多个构建版本。</li>
</ul>
</li>
</ul>
<h2 id="4-Qt-项目支持：简单-vs-复杂"><a href="#4-Qt-项目支持：简单-vs-复杂" class="headerlink" title="4. Qt 项目支持：简单 vs 复杂"></a>4. Qt 项目支持：简单 vs 复杂</h2><ul>
<li><p>对于简单 Qt 控制台程序：</p>
<ul>
<li><code>qmake</code> 配置极简，几行 <code>.pro</code> 文件即可。</li>
<li><code>CMake</code> 需要 FIND_PACKAGE、INCLUDE、添加目标与链接库等步骤。</li>
</ul>
</li>
<li><p>对于带 UI、类的项目：</p>
<ul>
<li><code>qmake</code> 自动处理 <code>Q_OBJECT</code> 和 <code>.ui</code> 文件。</li>
<li><code>CMake</code> 需显式使用 <code>QT_WRAP_CPP</code>、<code>QT_WRAP_UI</code> 宏处理。</li>
</ul>
</li>
</ul>
<h2 id="5-平台差异化处理"><a href="#5-平台差异化处理" class="headerlink" title="5. 平台差异化处理"></a>5. 平台差异化处理</h2><ul>
<li><p>Windows 子系统区分：</p>
<ul>
<li>qmake：通过 <code>CONFIG += console</code> 控制程序类型。</li>
<li>CMake：通过 <code>WIN32</code> 关键字、定义 <code>QT_USE_QTMAIN</code> 实现。</li>
</ul>
</li>
<li><p>RC 文件支持：</p>
<ul>
<li>qmake：使用 <code>RC_FILE = xxx.rc</code></li>
<li>CMake：需手动设定 <code>ENABLE_LANGUAGE(RC)</code> 等配置。</li>
</ul>
</li>
</ul>
<h2 id="6-构建类型管理"><a href="#6-构建类型管理" class="headerlink" title="6. 构建类型管理"></a>6. 构建类型管理</h2><ul>
<li>qmake：使用 <code>make debug</code> &#x2F; <code>make release</code></li>
<li>CMake：推荐使用构建目录 + <code>-DCMAKE_BUILD_TYPE=Debug/Release</code></li>
</ul>
<h2 id="7、常用构建项对照表"><a href="#7、常用构建项对照表" class="headerlink" title="7、常用构建项对照表"></a>7、常用构建项对照表</h2><table>
<thead>
<tr>
<th>功能</th>
<th>qmake 语法（.pro）</th>
<th>CMake 语法（CMakeLists.txt）</th>
<th>中文说明</th>
</tr>
</thead>
<tbody><tr>
<td>项目名</td>
<td><code>TARGET = MyApp</code></td>
<td><code>project(MyApp)</code></td>
<td>设置工程名称</td>
</tr>
<tr>
<td>应用类型</td>
<td><code>TEMPLATE = app</code></td>
<td><code>add_executable(...)</code></td>
<td>声明生成目标为应用程序</td>
</tr>
<tr>
<td>Qt 模块</td>
<td><code>QT += core gui widgets</code></td>
<td><code>find_package(Qt5 REQUIRED COMPONENTS Core Gui Widgets)</code></td>
<td>添加 Qt 模块</td>
</tr>
<tr>
<td>源文件</td>
<td><code>SOURCES += main.cpp</code></td>
<td><code>add_executable(MyApp main.cpp)</code></td>
<td>添加源文件</td>
</tr>
<tr>
<td>头文件</td>
<td><code>HEADERS += main.h</code></td>
<td>与源文件一同加入即可</td>
<td>添加头文件</td>
</tr>
<tr>
<td>UI 文件</td>
<td><code>FORMS += ui.ui</code></td>
<td><code>set(CMAKE_AUTOUIC ON)</code> 并加入列表</td>
<td>Qt Designer UI 文件</td>
</tr>
<tr>
<td>资源文件</td>
<td><code>RESOURCES += res.qrc</code></td>
<td><code>set(CMAKE_AUTORCC ON)</code> 并加入列表</td>
<td>Qt 资源文件</td>
</tr>
<tr>
<td>包含路径</td>
<td><code>INCLUDEPATH += ./include</code></td>
<td><code>target_include_directories(MyApp PRIVATE ./include)</code></td>
<td>添加头文件搜索路径</td>
</tr>
<tr>
<td>宏定义</td>
<td><code>DEFINES += MY_DEFINE=1</code></td>
<td><code>add_definitions(-DMY_DEFINE=1)</code></td>
<td>编译时宏定义</td>
</tr>
<tr>
<td>编译器参数</td>
<td><code>QMAKE_CXXFLAGS += -Wall</code></td>
<td><code>target_compile_options(...)</code></td>
<td>添加编译器选项</td>
</tr>
<tr>
<td>链接库</td>
<td><code>LIBS += -lmylib</code></td>
<td><code>target_link_libraries(MyApp mylib)</code></td>
<td>链接外部库</td>
</tr>
<tr>
<td>库路径</td>
<td><code>LIBS += -L./libs</code></td>
<td><code>link_directories(./libs)</code>（不推荐）</td>
<td>添加库搜索路径</td>
</tr>
<tr>
<td>编译模式</td>
<td><code>CONFIG += debug</code></td>
<td><code>if(CMAKE_BUILD_TYPE STREQUAL &quot;Debug&quot;)</code></td>
<td>指定调试模式</td>
</tr>
<tr>
<td>子项目</td>
<td><code>SUBDIRS += submodule</code></td>
<td><code>add_subdirectory(submodule)</code></td>
<td>添加子目录模块</td>
</tr>
<tr>
<td>使用 C++11</td>
<td><code>CONFIG += c++11</code></td>
<td><code>set(CMAKE_CXX_STANDARD 11)</code></td>
<td>设置 C++ 标准</td>
</tr>
<tr>
<td>包含 .pri 文件</td>
<td><code>include(service/service.pri)</code></td>
<td><code>include(...)</code> 或 <code>add_subdirectory()</code></td>
<td>引入模块配置</td>
</tr>
</tbody></table>
<hr>
<h2 id="8、示例转换：qmake-→-CMake"><a href="#8、示例转换：qmake-→-CMake" class="headerlink" title="8、示例转换：qmake → CMake"></a>8、示例转换：qmake → CMake</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置构建目标名称</span><br><span class="line">TARGET = MyApp                          # CMake: project(MyApp)</span><br><span class="line"></span><br><span class="line"># 设置构建类型为应用程序</span><br><span class="line">TEMPLATE = app                          # CMake: add_executable(...)</span><br><span class="line"></span><br><span class="line"># 引入 Qt 模块</span><br><span class="line">QT += core gui widgets    # CMake: find_package(Qt5 REQUIRED COMPONENTS Core Gui Widgets)</span><br><span class="line"></span><br><span class="line"># 添加源码文件</span><br><span class="line">SOURCES += main.cpp \                   # CMake: 列入 add_executable(...)</span><br><span class="line">           mainwindow.cpp</span><br><span class="line"></span><br><span class="line"># 添加头文件</span><br><span class="line">HEADERS += mainwindow.h                # CMake: 可直接列入 add_executable()</span><br><span class="line"></span><br><span class="line"># 添加 UI 设计文件</span><br><span class="line">FORMS += mainwindow.ui                 # CMake: set(CMAKE_AUTOUIC ON) 并列入 add_executable()</span><br><span class="line"></span><br><span class="line"># 添加 Qt 资源文件</span><br><span class="line">RESOURCES += res.qrc                   # CMake: set(CMAKE_AUTORCC ON) 并列入 add_executable()</span><br><span class="line"></span><br><span class="line"># 添加头文件搜索路径</span><br><span class="line">INCLUDEPATH += ./include     # CMake: target_include_directories(MyApp PRIVATE ./include)</span><br><span class="line"></span><br><span class="line"># 添加预编译宏</span><br><span class="line">DEFINES += MY_DEFINE=1                 # CMake: add_definitions(-DMY_DEFINE=1)</span><br><span class="line"></span><br><span class="line"># 添加编译器参数</span><br><span class="line">QMAKE_CXXFLAGS += -Wall              # CMake: target_compile_options(MyApp PRIVATE -Wall)</span><br><span class="line"></span><br><span class="line"># 添加库路径</span><br><span class="line">LIBS += -L./libs                       # CMake: link_directories($&#123;CMAKE_SOURCE_DIR&#125;/libs)</span><br><span class="line"></span><br><span class="line"># 链接库</span><br><span class="line">LIBS += -lmylib                       # CMake: target_link_libraries(MyApp PRIVATE mylib)</span><br><span class="line"></span><br><span class="line"># 使用 C++11 标准</span><br><span class="line">CONFIG += c++11                        # CMake: set(CMAKE_CXX_STANDARD 11)</span><br><span class="line"></span><br><span class="line"># 引入子模块配置</span><br><span class="line">include(./service/service.pri)# CMake: include($&#123;CMAKE_SOURCE_DIR&#125;/service/service.cmake)</span><br><span class="line"></span><br><span class="line"># Windows Linux macOS iOS Android</span><br><span class="line">android</span><br><span class="line">&#123;</span><br><span class="line">    QT += androidextras</span><br><span class="line">    ANDROID_PACKAGE_SOURCE_DIR = $$PWD/android</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9、示例转换：CMake-→-qmake"><a href="#9、示例转换：CMake-→-qmake" class="headerlink" title="9、示例转换：CMake → qmake"></a>9、示例转换：CMake → qmake</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定 CMake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)       <span class="comment"># qmake: 无等效项，固定版本由工具链决定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名称</span></span><br><span class="line"><span class="keyword">project</span>(MyApp)                             <span class="comment"># qmake: TARGET = MyApp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 Qt 的 MOC、UIC、RCC 自动处理</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)                      <span class="comment"># qmake: 默认启用</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)                      <span class="comment"># qmake: FORMS += xxx.ui</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)                      <span class="comment"># qmake: RESOURCES += xxx.qrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 C++ 标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)                 <span class="comment"># qmake: CONFIG += c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 Qt 模块</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 REQUIRED COMPONENTS Core Gui Widgets)   <span class="comment"># qmake: QT += core gui widgets</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyApp                       <span class="comment"># qmake: TEMPLATE = app；SOURCES += ...</span></span><br><span class="line">    main.cpp</span><br><span class="line">    mainwindow.cpp</span><br><span class="line">    mainwindow.h                           <span class="comment"># qmake: HEADERS += ...</span></span><br><span class="line">    mainwindow.ui                          <span class="comment"># qmake: FORMS += ...</span></span><br><span class="line">    res.qrc                                <span class="comment"># qmake: RESOURCES += ...</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置头文件包含路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MyApp PRIVATE ./<span class="keyword">include</span>)   <span class="comment"># qmake: INCLUDEPATH += ./include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加宏定义</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DMY_DEFINE=<span class="number">1</span>)                         <span class="comment"># qmake: DEFINES += MY_DEFINE=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加编译器参数</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(MyApp PRIVATE -Wall)           <span class="comment"># qmake: QMAKE_CXXFLAGS += -Wall</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加库路径（不推荐方式）</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs)            <span class="comment"># qmake: LIBS += -L./libs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接外部库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyApp PRIVATE mylib)            <span class="comment"># qmake: LIBS += -lmylib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入外部模块或子配置</span></span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/service/service.cmake)    <span class="comment"># qmake: include(service/service.pri)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if(WIN32) if(UNIX) if(APPLE) if(IOS) if(ANDROID) if(ANDROID)</span></span><br><span class="line"><span class="comment"># 仅在 Android 平台下执行</span></span><br><span class="line"><span class="keyword">if</span>(ANDROID)</span><br><span class="line">    <span class="keyword">set_property</span>(<span class="keyword">TARGET</span> your_target PROPERTY ANDROID_PACKAGE_SOURCE_DIR <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/android)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(your_target PRIVATE Qt5::AndroidExtras)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h2 id="10、qmake详细示例-细节配置"><a href="#10、qmake详细示例-细节配置" class="headerlink" title="10、qmake详细示例 细节配置"></a>10、qmake详细示例 细节配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -------------------------------------------------</span><br><span class="line"># 项目基本信息</span><br><span class="line"># -------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 项目名称（可选）</span><br><span class="line">TARGET = myapp</span><br><span class="line"></span><br><span class="line"># 生成的目标类型：app（应用程序） / lib（库） / subdirs（子工程）</span><br><span class="line">TEMPLATE = app</span><br><span class="line"></span><br><span class="line"># 编译使用的 Qt 模块（根据需要增减）</span><br><span class="line"># (network：网络模块 ，xml：xml配置文件依赖 ，svg图片依赖 )</span><br><span class="line">QT += core gui network xml svg</span><br><span class="line"></span><br><span class="line">#如果 Qt 主版本号大于 4（即使用的是 Qt 5 或 Qt 6），则在 .pro 文件中添加 widgets 模块。</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line"></span><br><span class="line"># 启用 C++ 标准</span><br><span class="line">CONFIG += c++11</span><br><span class="line"></span><br><span class="line"># Debug/Release 模式控制</span><br><span class="line">CONFIG += debug_and_release</span><br><span class="line">CONFIG += warn_on       # 编译时开启警告信息</span><br><span class="line"></span><br><span class="line"># 编译输出目录</span><br><span class="line">DESTDIR = bin           # 可执行文件输出目录</span><br><span class="line">OBJECTS_DIR = build/obj # 对象文件目录</span><br><span class="line">MOC_DIR = build/moc     # Qt 元对象代码生成目录</span><br><span class="line">UI_DIR = build/ui       # Qt UI 文件生成目录</span><br><span class="line">RCC_DIR = build/qrc     # Qt 资源编译文件目录</span><br><span class="line"></span><br><span class="line">#安卓设备下</span><br><span class="line">android &#123;</span><br><span class="line">    QT += androidextras</span><br><span class="line">    #ANDROID_PACKAGE_SOURCE_DIR = $$PWD/android</span><br><span class="line">&#125; else:win32 &#123;</span><br><span class="line">    QT -= androidextras</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#MSVC编译环境下声明 避免中文出现产生错误警告</span><br><span class="line">msvc &#123;</span><br><span class="line">	QMAKE_CFLAGS += /utf-8</span><br><span class="line">	QMAKE_CXXFLAGS += /utf-8</span><br><span class="line">	LIBS += -L$$PWD/&quot;/3part/lib/win64&quot; -lspdlogd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------</span><br><span class="line"># 源码和头文件</span><br><span class="line"># -------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 源文件</span><br><span class="line">SOURCES += \</span><br><span class="line">    main.cpp \</span><br><span class="line">    mainwindow.cpp \</span><br><span class="line">    networkmanager.cpp</span><br><span class="line"></span><br><span class="line"># 头文件</span><br><span class="line">HEADERS += \</span><br><span class="line">    mainwindow.h \</span><br><span class="line">    networkmanager.h</span><br><span class="line"></span><br><span class="line"># UI 文件（.ui 是 Qt Designer 的 XML 文件）</span><br><span class="line">FORMS += \</span><br><span class="line">    mainwindow.ui</span><br><span class="line"></span><br><span class="line"># Qt 资源文件</span><br><span class="line">RESOURCES += \</span><br><span class="line">    resources.qrc</span><br><span class="line"></span><br><span class="line">#项目分包，子目录，子配置</span><br><span class="line">include(./service/service.pri) #后台服务</span><br><span class="line">include(./ui/ui.pri) #ui界面</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------</span><br><span class="line"># 预处理器宏定义（如 DEBUG 宏）</span><br><span class="line"># -------------------------------------------------</span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line">DEFINES += APP_VERSION=\&quot;1.0.0\&quot;</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------</span><br><span class="line"># 额外包含目录</span><br><span class="line"># -------------------------------------------------</span><br><span class="line">INCLUDEPATH += $$PWD/include</span><br><span class="line">DEPENDPATH += $$PWD/include</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------</span><br><span class="line"># 添加外部库链接（静态库或动态库）</span><br><span class="line"># -------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 指定库目录（静态库或动态库 .lib / .a / .so 所在目录）</span><br><span class="line">LIBS += -L$$PWD/libs</span><br><span class="line"></span><br><span class="line"># 链接具体的库文件（注意平台差异）</span><br><span class="line">win32:LIBS += -lmywinlib</span><br><span class="line">unix:LIBS += -lmyunixlib</span><br><span class="line"></span><br><span class="line"># 如果是绝对路径链接</span><br><span class="line"># LIBS += $$PWD/libs/libabc.a</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------</span><br><span class="line"># 平台特定设置（Windows / macOS / Linux）</span><br><span class="line"># -------------------------------------------------</span><br><span class="line"></span><br><span class="line">win32 &#123;</span><br><span class="line">    RC_FILE = app.rc            # Windows 资源文件（图标/版本信息等）</span><br><span class="line">    DEFINES += WIN32_LEAN_AND_MEAN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">macx &#123;</span><br><span class="line">    ICON = icon.icns            # macOS 应用图标</span><br><span class="line">    QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.15</span><br><span class="line">    QMAKE_INFO_PLIST = Info.plist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unix:!macx &#123;</span><br><span class="line">    # Linux 特定的配置</span><br><span class="line">    QMAKE_CXXFLAGS += -fPIC</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------</span><br><span class="line"># 自定义构建指令（如拷贝资源文件）</span><br><span class="line"># -------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 构建结束后执行的操作，比如拷贝 DLL、配置文件等</span><br><span class="line">QMAKE_POST_LINK += $$quote(cp -r $$PWD/config $(DESTDIR)/)</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------</span><br><span class="line"># 子目录构建（用于大型项目）</span><br><span class="line"># TEMPLATE = subdirs 时才用得上</span><br><span class="line"># -------------------------------------------------</span><br><span class="line"># SUBDIRS += corelib guiapp tools</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>QT_配置</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt UI 显示器分辨率差异造成控件与字体缩放差异解决方案</title>
    <url>/2025/04/02/qt_UI_%E6%98%BE%E7%A4%BA%E5%99%A8%E5%88%86%E8%BE%A8%E7%8E%87%E5%B7%AE%E5%BC%82%E9%80%A0%E6%88%90%E6%8E%A7%E4%BB%B6%E4%B8%8E%E5%AD%97%E4%BD%93%E7%BC%A9%E6%94%BE%E5%B7%AE%E5%BC%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>如何手动配置 Qt 的高 DPI 缩放策略。</p>
</blockquote>
<hr>
<h2 id="一、目的说明"><a href="#一、目的说明" class="headerlink" title="一、目的说明"></a>一、目的说明</h2><p>在多分辨率或高 DPI 显示器环境下（例如 1080p 与 4K 显示器混用），默认 Qt 的缩放行为可能导致：</p>
<ul>
<li>控件尺寸显示不一致</li>
<li>字体和控件比例不正确</li>
</ul>
<p>为了解决这些问题，需要手动配置 Qt 的高 DPI 缩放策略。</p>
<hr>
<h2 id="二、控件与字体缩放不一致问题详解"><a href="#二、控件与字体缩放不一致问题详解" class="headerlink" title="二、控件与字体缩放不一致问题详解"></a>二、控件与字体缩放不一致问题详解</h2><p>在多分辨率显示器环境中，控件尺寸与字体大小常常表现不一致，原因在于它们的单位和缩放机制不同。</p>
<h3 id="1-控件大小设置（以像素为单位）"><a href="#1-控件大小设置（以像素为单位）" class="headerlink" title="1. 控件大小设置（以像素为单位）"></a>1. 控件大小设置（以像素为单位）</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">button-&gt;setFixedSize(<span class="number">100</span>, <span class="number">40</span>); <span class="comment">// 设置为 100x40 像素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>控件尺寸使用**像素（px）**为单位，<strong>不会自动参与 DPI 缩放</strong>。</li>
<li>在高 DPI 屏幕中，同样像素会显得更小。</li>
<li>如果未启用 Qt 的高 DPI 缩放机制，控件尺寸在高分屏上会“缩水”。</li>
</ul>
<h3 id="2-字体大小设置（以点为单位）"><a href="#2-字体大小设置（以点为单位）" class="headerlink" title="2. 字体大小设置（以点为单位）"></a>2. 字体大小设置（以点为单位）</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QFont <span class="built_in">font</span>;</span><br><span class="line"><span class="built_in">font</span>.setPointSize(<span class="number">12</span>);</span><br><span class="line">widget-&gt;setFont(<span class="built_in">font</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>字体大小使用**点（pt）**为单位，<strong>会自动随 DPI 缩放</strong>（启用了高 DPI 支持时）。</li>
<li>字体在不同 DPI 屏幕下显示更一致。</li>
</ul>
<hr>
<h3 id="📊-常见问题表现对比"><a href="#📊-常见问题表现对比" class="headerlink" title="📊 常见问题表现对比"></a>📊 常见问题表现对比</h3><table>
<thead>
<tr>
<th>场景</th>
<th>普通屏效果</th>
<th>高分屏效果（未处理）</th>
<th>问题说明</th>
</tr>
</thead>
<tbody><tr>
<td>控件大小</td>
<td>正常</td>
<td>显得很小</td>
<td>控件按像素渲染，未参与 DPI 缩放</td>
</tr>
<tr>
<td>字体大小</td>
<td>正常</td>
<td>看起来合理</td>
<td>字体按点单位自动缩放了</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、推荐配置方案"><a href="#三、推荐配置方案" class="headerlink" title="三、推荐配置方案"></a>三、推荐配置方案</h2><p>main函数内<br><code>QApplication a(argc, argv);</code>前,设置如下</p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用高 DPI 缩放支持（Qt 5.6+）</span></span><br><span class="line"><span class="attribute">QCoreApplication</span>::setAttribute(<span class="attribute">Qt</span>::AA_EnableHighDpiScaling);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用高分辨率图像资源（避免图标模糊）</span></span><br><span class="line"><span class="attribute">QCoreApplication</span>::setAttribute(<span class="attribute">Qt</span>::AA_UseHighDpiPixmaps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置缩放因子舍入策略为 PassThrough，避免被 Qt 自动四舍五入</span></span><br><span class="line"><span class="attribute">QGuiApplication</span>::setHighDpiScaleFactorRoundingPolicy(</span><br><span class="line">    <span class="attribute">Qt</span>::<span class="attribute">HighDpiScaleFactorRoundingPolicy</span>::PassThrough);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用自动根据屏幕分辨率缩放</span></span><br><span class="line">qputenv(<span class="string">&quot;QT_AUTO_SCREEN_SCALE_FACTOR&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// （可选）固定整个应用缩放比例为 1.25 倍（测试用）</span></span><br><span class="line"><span class="comment">// qputenv(&quot;QT_SCALE_FACTOR&quot;, &quot;1.25&quot;);</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、关键设置解释"><a href="#四、关键设置解释" class="headerlink" title="四、关键设置解释"></a>四、关键设置解释</h2><h3 id="1-Qt-HighDpiScaleFactorRoundingPolicy-PassThrough"><a href="#1-Qt-HighDpiScaleFactorRoundingPolicy-PassThrough" class="headerlink" title="1. Qt::HighDpiScaleFactorRoundingPolicy::PassThrough"></a>1. <code>Qt::HighDpiScaleFactorRoundingPolicy::PassThrough</code></h3><ul>
<li>不舍入缩放因子，例如 1.25 就保持为 1.25，而不是四舍五入为 1 或 2。</li>
<li>避免因缩放被改写导致控件或字体显示异常。</li>
<li>适用于需要精确缩放控制的应用。</li>
</ul>
<h3 id="2-QT-AUTO-SCREEN-SCALE-FACTOR-1"><a href="#2-QT-AUTO-SCREEN-SCALE-FACTOR-1" class="headerlink" title="2. QT_AUTO_SCREEN_SCALE_FACTOR=1"></a>2. <code>QT_AUTO_SCREEN_SCALE_FACTOR=1</code></h3><ul>
<li>根据当前显示器的 DPI 自动计算缩放因子。</li>
<li>多屏幕（不同 DPI）下自动适配。</li>
</ul>
<h3 id="3-AA-EnableHighDpiScaling"><a href="#3-AA-EnableHighDpiScaling" class="headerlink" title="3. AA_EnableHighDpiScaling"></a>3. <code>AA_EnableHighDpiScaling</code></h3><ul>
<li>启用 Qt 高 DPI 缩放支持。</li>
<li>这是启用缩放机制的基础配置。</li>
</ul>
<h3 id="4-AA-UseHighDpiPixmaps"><a href="#4-AA-UseHighDpiPixmaps" class="headerlink" title="4. AA_UseHighDpiPixmaps"></a>4. <code>AA_UseHighDpiPixmaps</code></h3><ul>
<li>图像资源也将使用高分辨率版本（如 2x PNG 图标），保证清晰度。</li>
</ul>
<h3 id="5-QT-SCALE-FACTOR-1-25（可选）"><a href="#5-QT-SCALE-FACTOR-1-25（可选）" class="headerlink" title="5. QT_SCALE_FACTOR=1.25（可选）"></a>5. <code>QT_SCALE_FACTOR=1.25</code>（可选）</h3><ul>
<li>手动设置应用缩放倍数，用于调试或临时适配不支持自动缩放的平台。</li>
</ul>
<hr>
<h2 id="五、效果总结"><a href="#五、效果总结" class="headerlink" title="五、效果总结"></a>五、效果总结</h2><ul>
<li>多显示器缩放一致性增强</li>
<li>控件与字体按比例精准缩放</li>
<li>界面清晰不模糊，特别适用于 2K&#x2F;4K 显示器</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>QT_UI配置</category>
      </categories>
      <tags>
        <tag>QT</tag>
        <tag>QT_UI</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt UI 界面无操作超时自动返回首页</title>
    <url>/2025/04/05/qt_UI_%E7%95%8C%E9%9D%A2%E6%97%A0%E6%93%8D%E4%BD%9C%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E8%BF%94%E5%9B%9E%E9%A6%96%E9%A1%B5/</url>
    <content><![CDATA[<blockquote>
<p>本文档介绍如何在 Qt 应用程序中实现“无操作一段时间后自动返回首页”的功能，适用于工业终端、信息展示屏等场景。</p>
</blockquote>
<hr>
<h2 id="🧠-实现原理"><a href="#🧠-实现原理" class="headerlink" title="🧠 实现原理"></a>🧠 实现原理</h2><p>通过自定义 <code>QApplication</code> 类，重载 <code>notify()</code> 方法来监听全局用户操作（如鼠标点击、键盘按键等），每次操作后重置一个计时器。当计时器超时后，触发槽函数自动返回主界面或首页。</p>
<hr>
<h2 id="🔧-步骤一：自定义-MyApplication-类"><a href="#🔧-步骤一：自定义-MyApplication-类" class="headerlink" title="🔧 步骤一：自定义 MyApplication 类"></a>🔧 步骤一：自定义 MyApplication 类</h2><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 QApplication 类，添加全局鼠标点击触发器</span></span><br><span class="line">class <span class="attribute">MyApplication</span> : public <span class="title">QApplication</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">    MyApplication(<span class="built_in">int</span>&amp; argc, char** argv) : QApplication(argc, argv) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> notify(QObject* receiver, QEvent* event) <span class="title">override</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;type() == <span class="attribute">QEvent</span>::MouseButtonPress) &#123; <span class="comment">// 检测鼠标按下事件</span></span><br><span class="line">            QMouseEvent* mouseEvent = static_cast&lt;QMouseEvent*&gt;(event);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是左键点击事件，重置计时器</span></span><br><span class="line">            <span class="keyword">if</span> (mouseEvent-&gt;buttons() &amp; <span class="attribute">Qt</span>::LeftButton) &#123;</span><br><span class="line">                <span class="keyword">if</span>(overallTimer != nullptr)</span><br><span class="line">                    overallTimer-&gt;start(); <span class="comment">// 重置计时器</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续传递事件给父类的 notify() 函数进行处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="attribute">QApplication</span>::notify(receiver, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧷-步骤二：main-函数中初始化计时器"><a href="#🧷-步骤二：main-函数中初始化计时器" class="headerlink" title="🧷 步骤二：main 函数中初始化计时器"></a>🧷 步骤二：main 函数中初始化计时器</h2><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &quot;main.h&quot;</span></span><br><span class="line"><span class="comment">//extern QTimer* overallTimer;</span></span><br><span class="line"></span><br><span class="line">QTimer* overallTimer = nullptr; <span class="comment">// 固定时间跳转至首页的计时器</span></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    MyApplication app(argc, argv);</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化计时器并挂到 app 对象上</span></span><br><span class="line">    overallTimer = <span class="keyword">new</span> QTimer(&amp;app);</span><br><span class="line">    overallTimer-&gt;start(<span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>);  <span class="comment">// 启动定时器：5分钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接超时信号到主窗口的返回首页槽函数</span></span><br><span class="line">    <span class="attribute">QObject</span>::connect(overallTimer, &amp;<span class="attribute">QTimer</span>::timeout, &amp;w, &amp;<span class="attribute">MainWindow</span>::backHomePage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📌-backHomePage-示例（MainWindow-内）"><a href="#📌-backHomePage-示例（MainWindow-内）" class="headerlink" title="📌 backHomePage 示例（MainWindow 内）"></a>📌 backHomePage 示例（MainWindow 内）</h2><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="attribute">MainWindow</span>::backHomePage() &#123;</span><br><span class="line">    <span class="comment">// 获取所有顶层窗口</span></span><br><span class="line">    <span class="keyword">const</span> auto widgets = <span class="attribute">QApplication</span>::topLevelWidgets();</span><br><span class="line">    <span class="keyword">for</span> (QWidget *<span class="attribute">widget</span> : widgets) &#123;</span><br><span class="line">        <span class="comment">// 判断是否为 QDialog 类型</span></span><br><span class="line">        <span class="keyword">if</span> (QDialog *dialog = qobject_cast&lt;QDialog *&gt;(widget)) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">&quot;Closing dialog:&quot;</span> &lt;&lt; dialog-&gt;objectName();</span><br><span class="line">            dialog-&gt;close(); <span class="comment">// 关闭对话框</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现返回主界面的逻辑</span></span><br><span class="line">    ui-&gt;stackedWidget-&gt;setCurrentIndex(<span class="number">0</span>);</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;长时间无操作，已返回首页&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-效果总结"><a href="#✅-效果总结" class="headerlink" title="✅ 效果总结"></a>✅ 效果总结</h2><table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>自动检测</td>
<td>鼠标、键盘、触摸等输入</td>
</tr>
<tr>
<td>自动重置</td>
<td>每次交互后自动重置定时器</td>
</tr>
<tr>
<td>超时触发</td>
<td>一段时间无操作后调用返回首页槽函数</td>
</tr>
<tr>
<td>应用场景</td>
<td>工控界面、自动售卖机、展览终端等</td>
</tr>
</tbody></table>
<hr>
<h2 id="📌-可拓展点"><a href="#📌-可拓展点" class="headerlink" title="📌 可拓展点"></a>📌 可拓展点</h2><ul>
<li>支持自定义超时时间、配置项持久化</li>
<li>支持动态阻止自动跳转（如播放视频时暂停倒计时）</li>
<li>集成状态栏提示“x秒后返回首页”等</li>
</ul>
<hr>
<blockquote>
<p>本功能适用于 Qt 5&#x2F;6 全平台，推荐用于工业控制和人机交互系统中提升用户体验。</p>
</blockquote>
]]></content>
      <categories>
        <category>QT_UI配置</category>
      </categories>
      <tags>
        <tag>QT</tag>
        <tag>QT_UI</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt Designer 中设置MainWindow页首菜单栏（QMenu 与 QAction）</title>
    <url>/2025/05/25/qt_UI_%E8%AE%BE%E7%BD%AEMainWindow%E9%A1%B5%E9%A6%96%E8%8F%9C%E5%8D%95%E6%A0%8F/</url>
    <content><![CDATA[<blockquote>
<p>本说明整理了如何在 Qt Designer 界面中设置首页顶部导航 QMenu 与 QAction，以及它们的关系和属性设置。</p>
</blockquote>
<hr>
<h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><p>Qt 中菜单栏结构为：</p>
<ul>
<li><strong>QMainWindow</strong><ul>
<li>QMenuBar（菜单栏）<ul>
<li>QMenu（菜单）<ul>
<li>QAction（菜单项）</li>
<li>分隔符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例如：文件(File) 菜单下包含“打开”、“保存”、“退出”等 QAction。<img src="https://cdn.jsdelivr.net/gh/zhishuyouling7766/myHexoBlog-Assets@main/image/2025-07-26%20131710.png"></p>
<hr>
<h2 id="二、设置步骤"><a href="#二、设置步骤" class="headerlink" title="二、设置步骤"></a>二、设置步骤</h2><h3 id="1-添加菜单栏"><a href="#1-添加菜单栏" class="headerlink" title="1. 添加菜单栏"></a>1. 添加菜单栏</h3><p>在 Qt Designer 中：</p>
<ol>
<li>新建的QT项目会自动存在一个 <strong>QMainWindow</strong>，作为界面主窗口，其会自带QMenuBar菜单栏</li>
<li>点击菜单栏，【在这里输入】区域，可以向其中添加菜单（如“文件”、“编辑”、“帮助”、“关于”）。</li>
</ol>
<h3 id="2-添加菜单项（QAction）"><a href="#2-添加菜单项（QAction）" class="headerlink" title="2. 添加菜单项（QAction）"></a>2. 添加菜单项（QAction）</h3><ol>
<li><p>在顶部菜单栏下的菜单中可以直接添加菜单项（对应 <code>QAction</code>）以及分隔符。</p>
</li>
<li><p>或者：打开“动作编辑器（Action 编辑器）”，点击“新建”按钮创建 QAction，然后将其拖动到视图的菜单中。</p>
<p>如何打开Action 编辑器：<img src="https://cdn.jsdelivr.net/gh/zhishuyouling7766/myHexoBlog-Assets@main/image/2025-07-26%20133012.png" alt="屏幕截图 2025-07-26 133012"></p>
</li>
<li><p>在Action 编辑器中，右键Action选项，可选择<strong>转到槽</strong>，设置事件</p>
</li>
</ol>
<hr>
<h2 id="三、Action-编辑器字段说明"><a href="#三、Action-编辑器字段说明" class="headerlink" title="三、Action 编辑器字段说明"></a>三、Action 编辑器字段说明</h2><table>
<thead>
<tr>
<th>字段</th>
<th>对应属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>文本 (T)</td>
<td><code>QAction::setText()</code></td>
<td>菜单中显示的文字</td>
</tr>
<tr>
<td>对象名称 (N)</td>
<td><code>QObject::setObjectName()</code></td>
<td>在代码中访问 QAction 的名称</td>
</tr>
<tr>
<td>提示 (Q)</td>
<td><code>QAction::setToolTip()</code></td>
<td>鼠标悬停时的提示文字</td>
</tr>
<tr>
<td>Icon Theme<br />Icon XDG Theme</td>
<td><code>QIcon::fromTheme()</code></td>
<td>从系统图标主题加载图标（常用于 Linux）<br />（不推荐使用，需要安装图标库）</td>
</tr>
<tr>
<td>图标 (I)</td>
<td><code>QAction::setIcon()</code></td>
<td>设置本地图标文件（可来自 资源<code>.qrc</code>）</td>
</tr>
<tr>
<td>可复选 (C)</td>
<td><code>QAction::setCheckable()</code></td>
<td>是否为可切换状态（勾选类菜单）</td>
</tr>
<tr>
<td>快捷方式 (S)</td>
<td><code>QAction::setShortcut()</code></td>
<td>设置快捷键，如 Ctrl+S</td>
</tr>
<tr>
<td>Menu Role</td>
<td><code>QAction::setMenuRole()</code></td>
<td>菜单角色（用于 macOS 菜单映射）<br />（试了一下，B用没有）</td>
</tr>
</tbody></table>
<p>Menu Role 选项说明（期待后续发现这玩意有什么用吧）：</p>
<ul>
<li><p><strong>NoRole</strong>：没有特定角色，默认设置。</p>
</li>
<li><p><strong>TextHeuristicRole</strong>：基于文本启用动作。</p>
</li>
<li><p><strong>ApplicationSpecificRole</strong>：用于应用程序特定的菜单项角色。</p>
</li>
<li><p><strong>AboutQtRole</strong>：关于 Qt 的菜单项。</p>
</li>
<li><p><strong>AboutRole</strong>：关于应用程序的菜单项。</p>
</li>
<li><p><strong>PreferencesRole</strong>：用于设置或偏好设置的菜单项。</p>
</li>
<li><p><strong>QuitRole</strong>：退出应用程序的菜单项。</p>
</li>
</ul>
<hr>
<h2 id="四、图标状态说明（图标-I-下拉菜单）"><a href="#四、图标状态说明（图标-I-下拉菜单）" class="headerlink" title="四、图标状态说明（图标 I 下拉菜单）"></a>四、图标状态说明（图标 I 下拉菜单）</h2><p>Qt 支持为不同状态设置不同图标：</p>
<table>
<thead>
<tr>
<th>显示项</th>
<th>Qt 枚举值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Normal Off</td>
<td><code>QIcon::Normal</code>, <code>QIcon::Off</code></td>
<td>默认状态</td>
</tr>
<tr>
<td>Normal On</td>
<td><code>QIcon::Normal</code>, <code>QIcon::On</code></td>
<td>激活状态</td>
</tr>
<tr>
<td>Disabled Off</td>
<td><code>QIcon::Disabled</code>, <code>QIcon::Off</code></td>
<td>禁用状态</td>
</tr>
<tr>
<td>Disabled On</td>
<td><code>QIcon::Disabled</code>, <code>QIcon::On</code></td>
<td>禁用状态且选中</td>
</tr>
<tr>
<td>Active Off</td>
<td><code>QIcon::Active</code>, <code>QIcon::Off</code></td>
<td>活跃状态（不可点击）</td>
</tr>
<tr>
<td>Active On</td>
<td><code>QIcon::Active</code>, <code>QIcon::On</code></td>
<td>活跃状态（可点击）</td>
</tr>
<tr>
<td>Selected Off</td>
<td><code>QIcon::Selected</code>, <code>QIcon::Off</code></td>
<td>选中状态（不可点击）</td>
</tr>
<tr>
<td>Selected On</td>
<td><code>QIcon::Selected</code>, <code>QIcon::On</code></td>
<td>选中状态（可点击）</td>
</tr>
</tbody></table>
<p>使用 <code>icon.addFile()</code> 可以为这些状态配置不同图标。</p>
<hr>
<h2 id="五、代码示例"><a href="#五、代码示例" class="headerlink" title="五、代码示例"></a>五、代码示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取动作对象</span></span><br><span class="line">QAction *actionOpen = ui-&gt;actionOpen;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文本和图标</span></span><br><span class="line">actionOpen-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Open File&quot;</span>);</span><br><span class="line">actionOpen-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/icons/open.png&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置快捷键</span></span><br><span class="line">actionOpen-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">QKeySequence</span>(<span class="string">&quot;Ctrl+O&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为可选中状态</span></span><br><span class="line">actionOpen-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">actionOpen-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);  <span class="comment">// 初始状态为未选中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接槽函数</span></span><br><span class="line"><span class="built_in">connect</span>(actionOpen, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::openFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置可用性和可见性</span></span><br><span class="line">actionOpen-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);    <span class="comment">// 启用</span></span><br><span class="line">actionOpen-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);    <span class="comment">// 显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动触发操作（比如在某些条件下自动执行）</span></span><br><span class="line">actionOpen-&gt;<span class="built_in">trigger</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 QAction 添加到菜单和工具栏</span></span><br><span class="line">ui-&gt;menuFile-&gt;<span class="built_in">addAction</span>(actionOpen);   <span class="comment">// 添加到菜单</span></span><br><span class="line">ui-&gt;toolBar-&gt;<span class="built_in">addAction</span>(actionOpen);    <span class="comment">// 添加到工具栏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置父对象（如果需要，通常由 Qt Designer 自动处理）</span></span><br><span class="line">actionOpen-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、菜单与工具栏共用-QAction"><a href="#六、菜单与工具栏共用-QAction" class="headerlink" title="六、菜单与工具栏共用 QAction"></a>六、菜单与工具栏共用 QAction</h2><p>【创建的 QAction 可以同时添加到菜单与工具栏中】<br>可以从Action编辑器中将现有的Action拖拽至多个菜单栏，也可使用代码操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(ui-&gt;actionOpen);</span><br><span class="line">menuFile-&gt;<span class="built_in">addAction</span>(ui-&gt;actionOpen);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="七、推荐资源管理方式"><a href="#七、推荐资源管理方式" class="headerlink" title="七、推荐资源管理方式"></a>七、推荐资源管理方式</h2><ul>
<li>图标资源放入 Qt Resource File (<code>.qrc</code>)</li>
<li>QAction 命名统一格式：<code>action+功能名</code>（如 <code>actionSave</code>）</li>
<li>使用 QAction 实现统一快捷方式、图标、状态切换</li>
</ul>
<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://doc.qt.io/qt-5/qaction.html">QAction 官方文档 (英文)</a></li>
<li><a href="https://doc.qt.io/qt-5/qmenu.html">QMenu 官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>QT_UI配置</category>
      </categories>
      <tags>
        <tag>QT</tag>
        <tag>QT_UI</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt for Android 使用 JNI 的完整指南</title>
    <url>/2025/03/09/qt_android_jni/</url>
    <content><![CDATA[<blockquote>
<p>本指南记录了如何在 Qt 项目中通过 JNI（Java Native Interface）调用 Android 原生 Java 方法，适用于需要访问系统功能（如 U 盘读写、广播、Activity 启动等）的场景。</p>
</blockquote>
<hr>
<h2 id="📁-项目结构建议"><a href="#📁-项目结构建议" class="headerlink" title="📁 项目结构建议"></a>📁 项目结构建议</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your_qt_project/</span><br><span class="line">├── main.cpp</span><br><span class="line">├── your_qt_project.pro</span><br><span class="line">├── android/</span><br><span class="line">│   ├── AndroidManifest.xml</span><br><span class="line">│   └── src/org/qtproject/example/activityhandler/</span><br><span class="line">│       ├── CustomActivity1.java</span><br><span class="line">│       ├── CustomActivity2.java</span><br><span class="line">│       └── CustomActivity3.java</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚙️-pro-文件配置"><a href="#⚙️-pro-文件配置" class="headerlink" title="⚙️ .pro 文件配置"></a>⚙️ <code>.pro</code> 文件配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    QT += androidextras  # 启用 Qt 封装的 JNI 支持模块</span><br><span class="line"></span><br><span class="line">    ANDROID_PACKAGE_SOURCE_DIR = $$PWD/android  # 使用自定义 Android 工程目录</span><br><span class="line"></span><br><span class="line">    # 可选：附加打包 Java 与 Manifest 文件，方便 IDE 显示</span><br><span class="line">    DISTFILES +=         android/AndroidManifest.xml         android/src/org/qtproject/example/activityhandler/CustomActivity1.java         android/src/org/qtproject/example/activityhandler/CustomActivity2.java         android/src/org/qtproject/example/activityhandler/CustomActivity3.java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📦-Java-类示例"><a href="#📦-Java-类示例" class="headerlink" title="📦 Java 类示例"></a>📦 Java 类示例</h2><p><strong>CustomActivity1.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.qtproject.example.activityhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomActivity1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">helloFromJava</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;JNI&quot;</span>, <span class="string">&quot;Hello from Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNtpServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pool.ntp.org&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyCpp</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🧩-Qt-中调用-Java-的多种方式总结"><a href="#🧩-Qt-中调用-Java-的多种方式总结" class="headerlink" title="🧩 Qt 中调用 Java 的多种方式总结"></a>🧩 Qt 中调用 Java 的多种方式总结</h1><h2 id="✅-1-调用-Java-静态方法（推荐）"><a href="#✅-1-调用-Java-静态方法（推荐）" class="headerlink" title="✅ 1. 调用 Java 静态方法（推荐）"></a>✅ 1. 调用 Java 静态方法（推荐）</h2><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="attribute">QAndroidJniObject</span>::callStaticMethod&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">    <span class="string">&quot;org/qtproject/example/activityhandler/CustomActivity1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloFromJava&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()V&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>适合调用 Java 的 <code>public static</code> 方法。</li>
<li>方法签名：<code>()V</code> 表示无参无返回。</li>
</ul>
<hr>
<h2 id="✅-2-创建-Java-对象并调用实例方法"><a href="#✅-2-创建-Java-对象并调用实例方法" class="headerlink" title="✅ 2. 创建 Java 对象并调用实例方法"></a>✅ 2. 创建 Java 对象并调用实例方法</h2><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QAndroidJniObject javaObj(<span class="string">&quot;org/qtproject/example/activityhandler/CustomActivity2&quot;</span>);</span><br><span class="line">javaObj.callMethod&lt;<span class="keyword">void</span>&gt;(<span class="string">&quot;nonStaticMethodName&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>适合 Java 的非静态方法。</li>
<li>支持多次交互使用。</li>
</ul>
<hr>
<h2 id="✅-3-调用带参数的方法"><a href="#✅-3-调用带参数的方法" class="headerlink" title="✅ 3. 调用带参数的方法"></a>✅ 3. 调用带参数的方法</h2><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QAndroidJniObject param = <span class="attribute">QAndroidJniObject</span>::fromString(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="attribute">QAndroidJniObject</span>::callStaticMethod&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">    <span class="string">&quot;org/qtproject/example/activityhandler/CustomActivity1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;printMessage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>,</span><br><span class="line">    param.object&lt;jstring&gt;()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(Ljava/lang/String;)V</code> 表示接收一个字符串参数，无返回值。</li>
<li>参数和返回值的 JNI 签名可参考 JNI 文档。</li>
</ul>
<hr>
<h2 id="✅-4-获取-Java-对象返回值（如-String）"><a href="#✅-4-获取-Java-对象返回值（如-String）" class="headerlink" title="✅ 4. 获取 Java 对象返回值（如 String）"></a>✅ 4. 获取 Java 对象返回值（如 String）</h2><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QAndroidJniObject result = <span class="attribute">QAndroidJniObject</span>::callStaticObjectMethod(</span><br><span class="line">    <span class="string">&quot;org/qtproject/example/activityhandler/CustomActivity&quot;</span>,</span><br><span class="line">    <span class="string">&quot;getNtpServer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()Ljava/lang/String;&quot;</span></span><br><span class="line">);</span><br><span class="line">QString str = result.toString();</span><br></pre></td></tr></table></figure>

<ul>
<li>适用于返回 Java 对象的情况，如 <code>String</code>。</li>
<li>返回值使用 <code>QAndroidJniObject</code> 接收并转为 QString。</li>
</ul>
<hr>
<h2 id="✅-5-使用-QAndroidJniEnvironment-进行底层-JNI-调用"><a href="#✅-5-使用-QAndroidJniEnvironment-进行底层-JNI-调用" class="headerlink" title="✅ 5. 使用 QAndroidJniEnvironment 进行底层 JNI 调用"></a>✅ 5. 使用 QAndroidJniEnvironment 进行底层 JNI 调用</h2><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QAndroidJniEnvironment env;</span><br><span class="line">jclass clazz = env-&gt;</span><br><span class="line">    FindClass(<span class="string">&quot;org/qtproject/example/activityhandler/CustomActivity1&quot;</span>);</span><br><span class="line">jmethodID methodId = env-&gt;GetStaticMethodID(clazz, <span class="string">&quot;helloFromJava&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">env-&gt;CallStaticVoidMethod(clazz, methodId);</span><br></pre></td></tr></table></figure>

<ul>
<li>适合高级场景：复杂参数控制、异常处理。</li>
<li>可结合原生 JNI 能力使用。</li>
</ul>
<hr>
<h2 id="✅-6-Java-调用-C-（Native-回调）"><a href="#✅-6-Java-调用-C-（Native-回调）" class="headerlink" title="✅ 6. Java 调用 C++（Native 回调）"></a>✅ 6. Java 调用 C++（Native 回调）</h2><p>Java 侧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomActivity1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyCpp</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 侧：</p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">extern <span class="string">&quot;C&quot;</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_org_qtproject_example_activityhandler_CustomActivity1_notifyCpp(JNIEnv *env, jobject obj) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;Java 调用了 C++&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Java 使用 <code>native</code> 关键字注册本地函数。</li>
<li>Qt 使用 JNIEXPORT 提供 C++ 回调实现。</li>
</ul>
<hr>
<h2 id="🔄-callStaticMethod-与-callStaticObjectMethod-区别详解"><a href="#🔄-callStaticMethod-与-callStaticObjectMethod-区别详解" class="headerlink" title="🔄 callStaticMethod&lt;T&gt;() 与 callStaticObjectMethod() 区别详解"></a>🔄 <code>callStaticMethod&lt;T&gt;()</code> 与 <code>callStaticObjectMethod()</code> 区别详解</h2><h3 id="callStaticMethod-：用于返回基本类型"><a href="#callStaticMethod-：用于返回基本类型" class="headerlink" title="callStaticMethod&lt;T&gt;()：用于返回基本类型"></a><code>callStaticMethod&lt;T&gt;()</code>：用于返回基本类型</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> result = <span class="attribute">QAndroidJniObject</span>::callStaticMethod&lt;jint&gt;(</span><br><span class="line">    <span class="string">&quot;org/example/MyJavaClass&quot;</span>,</span><br><span class="line">    <span class="string">&quot;getCount&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()I&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="callStaticObjectMethod-：用于返回-Java-对象类型"><a href="#callStaticObjectMethod-：用于返回-Java-对象类型" class="headerlink" title="callStaticObjectMethod()：用于返回 Java 对象类型"></a><code>callStaticObjectMethod()</code>：用于返回 Java 对象类型</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QAndroidJniObject result = <span class="attribute">QAndroidJniObject</span>::callStaticObjectMethod(</span><br><span class="line">    <span class="string">&quot;org/qtproject/example/activityhandler/CustomActivity&quot;</span>,</span><br><span class="line">    <span class="string">&quot;getNtpServer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()Ljava/lang/String;&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="🧠-对比总结："><a href="#🧠-对比总结：" class="headerlink" title="🧠 对比总结："></a>🧠 对比总结：</h3><table>
<thead>
<tr>
<th>比较项</th>
<th><code>callStaticMethod&lt;T&gt;()</code></th>
<th><code>callStaticObjectMethod()</code></th>
</tr>
</thead>
<tbody><tr>
<td>使用场景</td>
<td>Java 静态方法返回 <strong>基本类型</strong></td>
<td>Java 静态方法返回 <strong>对象类型</strong></td>
</tr>
<tr>
<td>返回类型</td>
<td>C++ 基础类型，如 <code>int</code>, <code>bool</code>, <code>void</code></td>
<td><code>QAndroidJniObject</code></td>
</tr>
<tr>
<td>JNI 方法签名</td>
<td>如：<code>()I</code>、<code>(I)V</code> 等</td>
<td>如：<code>()Ljava/lang/String;</code></td>
</tr>
<tr>
<td>获取返回值</td>
<td>直接使用变量</td>
<td>需 <code>.toString()</code> 或 <code>.object&lt;&gt;()</code> 提取</td>
</tr>
<tr>
<td>常见对象类型</td>
<td>不适用</td>
<td><code>String</code>, <code>List</code>, <code>自定义类</code> 等</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-AndroidManifest-xml-配置"><a href="#✅-AndroidManifest-xml-配置" class="headerlink" title="✅ AndroidManifest.xml 配置"></a>✅ AndroidManifest.xml 配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;org.qtproject.example.activityhandler&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:label</span>=<span class="string">&quot;JNIExampleApp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.CustomActivity1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.CustomActivity2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.CustomActivity3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📌-注意事项"><a href="#📌-注意事项" class="headerlink" title="📌 注意事项"></a>📌 注意事项</h2><ul>
<li>Java 类必须放在 <code>android/src/...</code> 路径下，包名需与路径一致。</li>
<li>Java 方法必须为 <code>public static</code> 才能被 <code>QAndroidJniObject::callStaticMethod</code> 调用。</li>
<li>方法签名 <code>&quot;()V&quot;</code> 表示无参数、无返回值；签名必须与 Java 方法匹配。</li>
<li>使用 <code>QAndroidJniObject::fromString</code> 创建 Java 字符串。</li>
<li>使用 <code>object&lt;jstring&gt;()</code>、<code>toString()</code> 等方式进行类型转换。</li>
</ul>
<hr>
<h2 id="🛠-构建与运行"><a href="#🛠-构建与运行" class="headerlink" title="🛠 构建与运行"></a>🛠 构建与运行</h2><ol>
<li>构建项目（建议先清除再构建）</li>
<li>连接 Android 设备</li>
<li>运行项目，查看 logcat 输出是否调用成功</li>
</ol>
<hr>
<h2 id="📚-延伸阅读"><a href="#📚-延伸阅读" class="headerlink" title="📚 延伸阅读"></a>📚 延伸阅读</h2><ul>
<li><a href="https://doc.qt.io/qt-5/qtandroidextras-index.html">Qt Android Extras 官方文档</a></li>
<li><a href="https://developer.android.com/training/articles/perf-jni#native-calls">JNI 方法签名表</a></li>
</ul>
]]></content>
      <categories>
        <category>QT实例</category>
      </categories>
      <tags>
        <tag>QT for Android</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidManifest.xml 配置详解</title>
    <url>/2025/03/03/qt_android_manifest_AndroidManifest%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>以下是 Qt for Android 应用中 <code>AndroidManifest.xml</code> 文件的完整配置及详细注释，适用于自定义权限、注册 Java 活动（Activity）、广播接收器以及加载 Qt 模块资源等场景。</p>
</blockquote>
<hr>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;org.qtproject.example.activityhandler&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionName</span>=<span class="string">&quot;-- %%INSERT_VERSION_NAME%% --&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionCode</span>=<span class="string">&quot;-- %%INSERT_VERSION_CODE%% --&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:installLocation</span>=<span class="string">&quot;auto&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>package</code>：你的应用 Java 包名</li>
<li><code>versionName</code>&#x2F;<code>versionCode</code>：构建工具自动替换版本</li>
<li><code>installLocation</code>：APK 默认安装位置（自动判断）</li>
</ul>
<hr>
<h2 id="🔐-权限声明"><a href="#🔐-权限声明" class="headerlink" title="🔐 权限声明"></a>🔐 权限声明</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CONNECTIVITY_INTERNAL&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_CHECKIN_PROPERTIES&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>声明了网络访问、存储访问、系统悬浮窗、后台服务等多个权限</li>
<li><code>MANAGE_EXTERNAL_STORAGE</code> 属于高权限，Android 11+ 需特殊授权</li>
<li><code>CONNECTIVITY_INTERNAL</code> 为系统权限，普通应用请谨慎使用</li>
</ul>
<hr>
<h2 id="👮-自定义权限"><a href="#👮-自定义权限" class="headerlink" title="👮 自定义权限"></a>👮 自定义权限</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.myapp.PERMISSION&quot;</span> <span class="attr">android:protectionLevel</span>=<span class="string">&quot;signature&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用于保护某些组件（如广播、服务）只能被签名应用访问</li>
</ul>
<hr>
<h2 id="📱-屏幕适配"><a href="#📱-屏幕适配" class="headerlink" title="📱 屏幕适配"></a>📱 屏幕适配</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">supports-screens</span> <span class="attr">android:largeScreens</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:normalScreens</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:anyDensity</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:smallScreens</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-应用配置及-Qt-Activity"><a href="#🧩-应用配置及-Qt-Activity" class="headerlink" title="🧩 应用配置及 Qt Activity"></a>🧩 应用配置及 Qt Activity</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;org.qtproject.qt5.android.bindings.QtApplication&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hardwareAccelerated</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;-- %%INSERT_APP_NAME%% --&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:extractNativeLibs</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 Qt 官方的 <code>QtApplication</code> 类</li>
<li>启用硬件加速，解压 native 库到内部目录</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;org.qtproject.example.activityhandler.JBmsActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;unspecified&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;adjustResize&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>主 Activity，为 Qt 应用入口</li>
<li>配置了 UI、字体、输入法等重载选项</li>
<li>含多条 <code>meta-data</code>，告知 Qt 加载哪些库和资源</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将该 Activity 作为 Launcher 主入口</li>
</ul>
<hr>
<h2 id="📂-Qt-所需资源和参数"><a href="#📂-Qt-所需资源和参数" class="headerlink" title="📂 Qt 所需资源和参数"></a>📂 Qt 所需资源和参数</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.lib_name&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;-- %%INSERT_APP_LIB_NAME%% --&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.qt_sources_resource_id&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@array/qt_sources&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.bundled_libs_resource_id&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@array/bundled_libs&quot;</span>/&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>所有 Qt 应用运行时必须包含的资源引用</li>
<li>使用构建工具动态替换</li>
</ul>
<hr>
<h2 id="🌗-Splash、样式、后台运行配置"><a href="#🌗-Splash、样式、后台运行配置" class="headerlink" title="🌗 Splash、样式、后台运行配置"></a>🌗 Splash、样式、后台运行配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.extract_android_style&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;minimal&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.background_running&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>minimal</code> 样式提取适用于 QML（Controls 2）更快更轻量</li>
<li>禁止应用后台运行避免崩溃</li>
</ul>
<hr>
<h2 id="👥-其他自定义-Activity"><a href="#👥-其他自定义-Activity" class="headerlink" title="👥 其他自定义 Activity"></a>👥 其他自定义 Activity</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.CustomActivity&quot;</span> <span class="attr">android:process</span>=<span class="string">&quot;:custom_activity&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.WriteToUsbActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>CustomActivity</code> 可用于独立进程扩展功能</li>
<li><code>WriteToUsbActivity</code> 用于 USB 相关交互，不导出</li>
</ul>
<hr>
<h2 id="📡-启动广播接收器"><a href="#📡-启动广播接收器" class="headerlink" title="📡 启动广播接收器"></a>📡 启动广播接收器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;.BootReceiver&quot;</span> <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:permission</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注册开机启动广播监听器</li>
</ul>
<hr>
<h2 id="✅-注意事项"><a href="#✅-注意事项" class="headerlink" title="✅ 注意事项"></a>✅ 注意事项</h2><ul>
<li>所有路径需与 Java 包结构一致</li>
<li><code>%%INSERT_...%%</code> 字段由 Qt 构建时自动替换，不要手动修改</li>
<li>如果目标 Android 版本 ≥ 11，强烈建议使用作用域存储 + SAF 替代老的存储权限</li>
</ul>
<hr>
<h1 id="最终完整实例："><a href="#最终完整实例：" class="headerlink" title="最终完整实例："></a>最终完整实例：</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">package</span>=<span class="string">&quot;org.qtproject.example.activityhandler&quot;</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">android:versionName</span>=<span class="string">&quot;-- %%INSERT_VERSION_NAME%% --&quot;</span> <span class="attr">android:versionCode</span>=<span class="string">&quot;-- %%INSERT_VERSION_CODE%% --&quot;</span> <span class="attr">android:installLocation</span>=<span class="string">&quot;auto&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--android:sharedUserId=&quot;android.uid.system&quot;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- The following comment will be replaced upon deployment with default permissions based on the dependencies of the application.</span></span><br><span class="line"><span class="comment">         Remove the comment if you do not require these default permissions. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- %%INSERT_PERMISSIONS --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- The following comment will be replaced upon deployment with default features based on the dependencies of the application.</span></span><br><span class="line"><span class="comment">         Remove the comment if you do not require these default features. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- %%INSERT_FEATURES --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CONNECTIVITY_INTERNAL&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.myapp.PERMISSION&quot;</span> <span class="attr">android:protectionLevel</span>=<span class="string">&quot;signature&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">supports-screens</span> <span class="attr">android:largeScreens</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:normalScreens</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:anyDensity</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:smallScreens</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:hardwareAccelerated</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;org.qtproject.qt5.android.bindings.QtApplication&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;-- %%INSERT_APP_NAME%% --&quot;</span> <span class="attr">android:extractNativeLibs</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:configChanges</span>=<span class="string">&quot;orientation|uiMode|screenLayout|screenSize|smallestScreenSize|layoutDirection|locale|fontScale|keyboard|keyboardHidden|navigation|mcc|mnc|density&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;org.qtproject.example.activityhandler.JBmsActivity&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;-- %%INSERT_APP_NAME%% --&quot;</span> <span class="attr">android:screenOrientation</span>=<span class="string">&quot;unspecified&quot;</span> <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTop&quot;</span> <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;adjustResize&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Application arguments --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- meta-data android:name=&quot;android.app.arguments&quot; android:value=&quot;arg1 arg2 arg3&quot;/ --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Application arguments --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.lib_name&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;-- %%INSERT_APP_LIB_NAME%% --&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.qt_sources_resource_id&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@array/qt_sources&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.repository&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;default&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.qt_libs_resource_id&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@array/qt_libs&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.bundled_libs_resource_id&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@array/bundled_libs&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Deploy Qt libs as part of package --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.bundle_local_qt_libs&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;-- %%BUNDLE_LOCAL_QT_LIBS%% --&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Run with local libs --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.use_local_qt_libs&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;-- %%USE_LOCAL_QT_LIBS%% --&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.libs_prefix&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;/data/local/tmp/qt/&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.load_local_libs_resource_id&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@array/load_local_libs&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.load_local_jars&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;-- %%INSERT_LOCAL_JARS%% --&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.static_init_classes&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;-- %%INSERT_INIT_CLASSES%% --&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Used to specify custom system library path to run with local system libs --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;meta-data android:name=&quot;android.app.system_libs_prefix&quot; android:value=&quot;/system/lib/&quot;/&gt; --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  Messages maps --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:value</span>=<span class="string">&quot;@string/ministro_not_found_msg&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.ministro_not_found_msg&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:value</span>=<span class="string">&quot;@string/ministro_needed_msg&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.ministro_needed_msg&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:value</span>=<span class="string">&quot;@string/fatal_error_msg&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.fatal_error_msg&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:value</span>=<span class="string">&quot;@string/unsupported_android_version&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.unsupported_android_version&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  Messages maps --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Splash screen --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Orientation-specific (portrait/landscape) data is checked first. If not available for current orientation,</span></span><br><span class="line"><span class="comment">                 then android.app.splash_screen_drawable. For best results, use together with splash_screen_sticky and</span></span><br><span class="line"><span class="comment">                 use hideSplashScreen() with a fade-out animation from Qt Android Extras to hide the splash screen when you</span></span><br><span class="line"><span class="comment">                 are done populating your window with content. --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- meta-data android:name=&quot;android.app.splash_screen_drawable_portrait&quot; android:resource=&quot;@drawable/logo_portrait&quot; / --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- meta-data android:name=&quot;android.app.splash_screen_drawable_landscape&quot; android:resource=&quot;@drawable/logo_landscape&quot; / --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- meta-data android:name=&quot;android.app.splash_screen_drawable&quot; android:resource=&quot;@drawable/logo&quot;/ --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- meta-data android:name=&quot;android.app.splash_screen_sticky&quot; android:value=&quot;true&quot;/ --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Splash screen --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Background running --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Warning: changing this value to true may cause unexpected crashes if the</span></span><br><span class="line"><span class="comment">                          application still try to draw after</span></span><br><span class="line"><span class="comment">                          &quot;applicationStateChanged(Qt::ApplicationSuspended)&quot;</span></span><br><span class="line"><span class="comment">                          signal is sent! --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.background_running&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Background running --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- auto screen scale factor --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.auto_screen_scale_factor&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- auto screen scale factor --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- extract android style --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- available android:values :</span></span><br><span class="line"><span class="comment">                * default - In most cases this will be the same as &quot;full&quot;, but it can also be something else if needed, e.g., for compatibility reasons</span></span><br><span class="line"><span class="comment">                * full - useful QWidget &amp; Quick Controls 1 apps</span></span><br><span class="line"><span class="comment">                * minimal - useful for Quick Controls 2 apps, it is much faster than &quot;full&quot;</span></span><br><span class="line"><span class="comment">                * none - useful for apps that don&#x27;t use any of the above Qt modules</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.extract_android_style&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;minimal&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- extract android style --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:process</span>=<span class="string">&quot;:custom_activity&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;.CustomActivity&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;-- %%INSERT_APP_NAME%% --&quot;</span> <span class="attr">android:screenOrientation</span>=<span class="string">&quot;unspecified&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- android:process=&quot;:qt&quot; is needed to force the service to run on a separate process than the Activity --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.lib_name&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;-- %%INSERT_APP_LIB_NAME%% --&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.WriteToUsbActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;-- %%INSERT_APP_NAME%% --&quot;</span> <span class="attr">android:screenOrientation</span>=<span class="string">&quot;unspecified&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- For adding service(s) please check: https://wiki.qt.io/AndroidServices --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;.BootReceiver&quot;</span> <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:permission</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_CHECKIN_PROPERTIES&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>QT实例</category>
      </categories>
      <tags>
        <tag>QT for Android</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt/C++ 项目集成 yaml-cpp 并实现配置持久化读取总结</title>
    <url>/2025/07/03/qt_cmake_yaml-cpp%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文档总结如何在 Qt 项目中集成 <code>yaml-cpp</code> 并实现配置文件读取过程中遇到的问题及解决方案，适用于 Windows 构建环境，也适用于部署到 Linux&#x2F;Android 等嵌入式平台。</p>
</blockquote>
<hr>
<p>⚠️项目需以CMake配置。</p>
<p>（qmake配置的情况下，win\linux\android各平台需要不同配置，无法做到同质化适配）</p>
<hr>
<h2 id="✅-项目目标"><a href="#✅-项目目标" class="headerlink" title="✅ 项目目标"></a>✅ 项目目标</h2><ul>
<li>将 <code>yaml-cpp</code> 源码集成进 Qt 项目，无需额外安装库</li>
<li>从 <code>config.yaml</code> 文件中读取配置项（如 username）</li>
<li>将构建输出的可执行文件放入 <code>bin/</code> 目录</li>
<li>保证 Qt 项目在 MinGW、MSVC两种编译器下构建成功</li>
<li>实现路径跨平台兼容、异常安全</li>
</ul>
<hr>
<h2 id="📁-工程结构推荐"><a href="#📁-工程结构推荐" class="headerlink" title="📁 工程结构推荐"></a>📁 工程结构推荐</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">untitled_project/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mainwindow.cpp/h/ui</span><br><span class="line">├── yaml-cpp/               # 第三方库源码（文件夹）</span><br><span class="line">└── bin/                    # 可执行文件输出目录</span><br><span class="line">	└── config.yaml             # YAML 配置文件</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔧-1-CMake-配置重点"><a href="#🔧-1-CMake-配置重点" class="headerlink" title="🔧 1. CMake 配置重点"></a>🔧 1. CMake 配置重点</h2><h3 id="✅-设置可执行文件输出到-bin"><a href="#✅-设置可执行文件输出到-bin" class="headerlink" title="✅ 设置可执行文件输出到 bin&#x2F;"></a>✅ 设置可执行文件输出到 bin&#x2F;</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>

<h3 id="✅-将从github上下载到的项目文件夹去掉多于后缀，更名为yaml-cpp"><a href="#✅-将从github上下载到的项目文件夹去掉多于后缀，更名为yaml-cpp" class="headerlink" title="✅ 将从github上下载到的项目文件夹去掉多于后缀，更名为yaml-cpp"></a>✅ 将从github上下载到的项目文件夹去掉多于后缀，更名为<code>yaml-cpp</code></h3><h3 id="✅-添加-yaml-cpp-子目录并链接"><a href="#✅-添加-yaml-cpp-子目录并链接" class="headerlink" title="✅ 添加 yaml-cpp 子目录并链接"></a>✅ 添加 yaml-cpp 子目录并链接</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 yaml-cpp 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(yaml-cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加yaml-cpp</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    Qt<span class="variable">$&#123;QT_VERSION_MAJOR&#125;</span>::Widgets</span><br><span class="line">    yaml-cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含 yaml-cpp 头文件</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    PRIVATE yaml-cpp/<span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📦-2-推荐使用的稳定版本"><a href="#📦-2-推荐使用的稳定版本" class="headerlink" title="📦 2. 推荐使用的稳定版本"></a>📦 2. 推荐使用的稳定版本</h2><p>为避免与某些 MSVC 编译器不兼容，推荐使用 yaml-cpp 的稳定版本：</p>
<ul>
<li>🔗 <strong>yaml-cpp v0.7.0</strong> 下载地址：<br><a href="https://github.com/jbeder/yaml-cpp/releases/tag/yaml-cpp-0.7.0">https://github.com/jbeder/yaml-cpp/releases/tag/yaml-cpp-0.7.0</a></li>
</ul>
<hr>
<h2 id="🧠-3-路径处理推荐写法"><a href="#🧠-3-路径处理推荐写法" class="headerlink" title="🧠 3. 路径处理推荐写法"></a>🧠 3. 路径处理推荐写法</h2><h3 id="✅-使用-applicationDirPath-获取-exe-所在目录"><a href="#✅-使用-applicationDirPath-获取-exe-所在目录" class="headerlink" title="✅ 使用 applicationDirPath 获取 .exe 所在目录"></a>✅ 使用 applicationDirPath 获取 .exe 所在目录</h3><p>将<code>config.yaml</code>放置入bin目录，以程序运行相对路径获取<code>.yaml</code>路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString path = QCoreApplication::<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/config.yaml&quot;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📄-4-完成上述所有配置后，QT-C-示例代码"><a href="#📄-4-完成上述所有配置后，QT-C-示例代码" class="headerlink" title="📄 4. 完成上述所有配置后，QT C++示例代码"></a>📄 4. 完成上述所有配置后，QT C++示例代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果出现 YAML文件不存在 YAML文件格式错误 访问了不存在的字段</span></span><br><span class="line"><span class="comment">//可能会出现报错弹窗： Microsoft Visual C++ Runtime Library 抛出的 运行时崩溃错误 abort()报错</span></span><br><span class="line"><span class="comment">//需要以try catch包裹代码</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">//程序执行文件所在目录,把 / 转换成当前系统的分隔符</span></span><br><span class="line"> QString appDir = QDir::<span class="built_in">toNativeSeparators</span>(QCoreApplication::<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/&quot;</span>);</span><br><span class="line"> <span class="comment">//配置.yaml文件地址</span></span><br><span class="line"> QString filePath = appDir + <span class="string">&quot;config.yaml&quot;</span>;</span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;配置文件路径:&quot;</span> &lt;&lt; filePath;</span><br><span class="line"> <span class="comment">//使用 YAML-CPP 库来加载一个 YAML 配置文件，并将其解析为一个 YAML::Node 节点对象</span></span><br><span class="line"> YAML::Node config = YAML::<span class="built_in">LoadFile</span>(filePath.<span class="built_in">toStdString</span>());</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//通过YAML::Node 节点对象获取数据       </span></span><br><span class="line"> QString username = QString::<span class="built_in">fromStdString</span>(config[<span class="string">&quot;username&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;());</span><br><span class="line"> QString password = QString::<span class="built_in">fromStdString</span>(config[<span class="string">&quot;password&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;());</span><br><span class="line"> QString host = QString::<span class="built_in">fromStdString</span>(config[<span class="string">&quot;server&quot;</span>][<span class="string">&quot;host&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;());</span><br><span class="line"> <span class="type">int</span> port = config[<span class="string">&quot;server&quot;</span>][<span class="string">&quot;port&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="type">bool</span> logging = config[<span class="string">&quot;features&quot;</span>][<span class="string">&quot;enable_logging&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">bool</span>&gt;();</span><br><span class="line"> <span class="type">bool</span> cache = config[<span class="string">&quot;features&quot;</span>][<span class="string">&quot;enable_cache&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">bool</span>&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;用户名:&quot;</span> &lt;&lt; username;</span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;密码:&quot;</span> &lt;&lt; password;</span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;服务器地址:&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; port;</span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;是否启用日志:&quot;</span> &lt;&lt; logging;</span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;是否启用缓存:&quot;</span> &lt;&lt; cache;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; roleNode : config[<span class="string">&quot;roles&quot;</span>]) &#123;</span><br><span class="line">  QString role = QString::<span class="built_in">fromStdString</span>(roleNode.<span class="built_in">as</span>&lt;std::string&gt;());</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;角色:&quot;</span> &lt;&lt; role;</span><br><span class="line"> &#125;</span><br><span class="line">        </span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line"> <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;读取配置失败:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚠️-常见问题汇总"><a href="#⚠️-常见问题汇总" class="headerlink" title="⚠️ 常见问题汇总"></a>⚠️ 常见问题汇总</h2><table>
<thead>
<tr>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><code>no viable conversion from QString to std::string</code></td>
<td>使用 <code>toStdString()</code></td>
</tr>
<tr>
<td><code>is_in_range</code> 模板报错（MSVC）</td>
<td>使用低版本稳定版 <code>yaml-cpp</code> 或改用 MinGW</td>
</tr>
<tr>
<td>YAML::Load 崩溃或异常</td>
<td>加上 <code>try-catch</code> 捕获错误</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-示例-config-yaml"><a href="#✅-示例-config-yaml" class="headerlink" title="✅ 示例 config.yaml"></a>✅ 示例 config.yaml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">username:</span> <span class="string">zhangbh</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">features:</span></span><br><span class="line">  <span class="attr">enable_logging:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable_cache:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">roles:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">admin</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">user</span></span><br></pre></td></tr></table></figure>

<hr>
<p>如需部署到 Linux&#x2F;Android，只需切换工具链后重新构建即可。</p>
]]></content>
      <categories>
        <category>QT_配置</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 传统日志机制示例解析</title>
    <url>/2025/04/12/qt_%E4%BC%A0%E7%BB%9F%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍如何将 Qt 自带的日志（如 <code>qDebug()</code>、<code>qWarning()</code> 等）重定向到文件保存，并适配多线程环境。</p>
</blockquote>
<hr>
<h2 id="📌-基本概念"><a href="#📌-基本概念" class="headerlink" title="📌 基本概念"></a>📌 基本概念</h2><p>Qt 提供如下日志宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;调试信息&quot;</span>;</span><br><span class="line"><span class="built_in">qInfo</span>()&lt;&lt; <span class="string">&quot;一般信息（Qt 5.5+）&quot;</span>;</span><br><span class="line"><span class="built_in">qWarning</span>()&lt;&lt; <span class="string">&quot;警告信息&quot;</span>;</span><br><span class="line"><span class="built_in">qCritical</span>()&lt;&lt; <span class="string">&quot;严重错误信息&quot;</span>;</span><br><span class="line"><span class="built_in">qFatal</span>(<span class="string">&quot;致命错误信息&quot;</span>); <span class="comment">// 致命错误，弹出警告提示框，程序终止</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，这些信息输出到控制台。为了保存到文件，需要使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qInstallMessageHandler</span>(myMessageHandler);</span><br></pre></td></tr></table></figure>

<p>它注册一个全局日志回调函数 <code>myMessageHandler</code>，你可以在此函数中决定如何处理日志，比如写入文件。</p>
<hr>
<h2 id="🧱-实现步骤"><a href="#🧱-实现步骤" class="headerlink" title="🧱 实现步骤"></a>🧱 实现步骤</h2><h3 id="1-定义日志处理函数"><a href="#1-定义日志处理函数" class="headerlink" title="1. 定义日志处理函数"></a>1. 定义日志处理函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myMessageHandler</span><span class="params">(QtMsgType type, </span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> QMessageLogContext &amp;context, </span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> QString &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> QMutex mutex; <span class="comment">//加锁</span></span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置相对地址</span></span><br><span class="line">    QString logPath = QCoreApplication::<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/logs/mylog.txt&quot;</span>;</span><br><span class="line">    <span class="built_in">QDir</span>().<span class="built_in">mkpath</span>(<span class="built_in">QFileInfo</span>(logPath).<span class="built_in">absolutePath</span>());  <span class="comment">// 确保目录存在</span></span><br><span class="line"></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(logPath)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::WriteOnly | QIODevice::Append))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    QString typeStr;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> QtDebugMsg:    typeStr = <span class="string">&quot;DEBUG&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QtInfoMsg:     typeStr = <span class="string">&quot;INFO&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QtWarningMsg:  typeStr = <span class="string">&quot;WARNING&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QtCriticalMsg: typeStr = <span class="string">&quot;CRITICAL&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QtFatalMsg:    typeStr = <span class="string">&quot;FATAL&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>) &lt;&lt; <span class="string">&quot;] &quot;</span></span><br><span class="line">        &lt;&lt; typeStr &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg</span><br><span class="line">        &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; context.file &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; context.line</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; context.function &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-在-main-中注册日志处理器"><a href="#2-在-main-中注册日志处理器" class="headerlink" title="2.  在 main() 中注册日志处理器"></a>2.  在 <code>main()</code> 中注册日志处理器</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ✅ 安装日志处理器（必须放在 QApplication 创建之前）</span></span><br><span class="line">    <span class="built_in">qInstallMessageHandler</span>(myMessageHandler);  </span><br><span class="line"></span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;	<span class="comment">// 创建 Qt 应用实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从这里开始的日志都会被捕捉写入 mylog.txt</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;程序启动&quot;</span>;                    </span><br><span class="line">    </span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-多线程安全"><a href="#✅-多线程安全" class="headerlink" title="✅ 多线程安全"></a>✅ 多线程安全</h2><p><code>myMessageHandler</code> 使用 <code>QMutexLocker</code> 来保证写入文件时线程安全，避免多线程并发写日志时出错。</p>
<hr>
<h2 id="🎯-补充技巧"><a href="#🎯-补充技巧" class="headerlink" title="🎯 补充技巧"></a>🎯 补充技巧</h2><ul>
<li>如不想弹出控制台，可在 <code>.pro</code> 文件中移除 <code>CONFIG += console</code></li>
<li>可配合 <code>QLoggingCategory</code> 实现模块化日志输出</li>
<li>若需格式控制，可用 <code>qSetMessagePattern()</code> 设置全局输出格式</li>
</ul>
<hr>
<h2 id="📄-输出示例（mylog-txt）"><a href="#📄-输出示例（mylog-txt）" class="headerlink" title="📄 输出示例（mylog.txt）"></a>📄 输出示例（mylog.txt）</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[2025-07-25 11:48:09] DEBUG: 程序启动 </span><br><span class="line">	(D:\myProject\qt\untitled\main.cpp:48, int __cdecl main(int,char *[]))</span><br><span class="line">[2025-07-25 11:48:09] WARNING: 警告信息 </span><br><span class="line">	(D:\myProject\qt\untitled\main.cpp:49, int __cdecl main(int,char *[]))</span><br><span class="line">[2025-07-25 11:48:09] CRITICAL: 严重错误信息 </span><br><span class="line">	(D:\myProject\qt\untitled\main.cpp:50, int __cdecl main(int,char *[]))</span><br><span class="line">[2025-07-25 11:48:09] FATAL: 致命错误信息 </span><br><span class="line">	(D:\myProject\qt\untitled\main.cpp:51, int __cdecl main(int,char *[]))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📦-推荐使用场景"><a href="#📦-推荐使用场景" class="headerlink" title="📦 推荐使用场景"></a>📦 推荐使用场景</h2><ul>
<li>小型项目：<code>qDebug()</code> + <code>myMessageHandler</code></li>
<li>中型项目：可引入 <code>spdlog</code> 等日志库结合使用</li>
</ul>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 传统线程与线程池机制对比总结</title>
    <url>/2025/06/14/qt_%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%AE%E5%BC%82%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>本文阐述了传统线程和线程池在应用场景和用法上的区别和使用要点。</p>
</blockquote>
<hr>
<h2 id="一、核心区别总览"><a href="#一、核心区别总览" class="headerlink" title="一、核心区别总览"></a>一、核心区别总览</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>QThread 传统线程</th>
<th>QThreadPool + QRunnable 线程池</th>
</tr>
</thead>
<tbody><tr>
<td>启动方式</td>
<td><code>thread-&gt;start()</code></td>
<td><code>threadPool-&gt;start(runnable)</code></td>
</tr>
<tr>
<td>执行入口</td>
<td>重写 <code>QThread::run()</code></td>
<td>实现 <code>QRunnable::run()</code></td>
</tr>
<tr>
<td>是否为子线程对象本体</td>
<td>✅ <code>QThread</code> 是子线程</td>
<td>❌ <code>QRunnable</code> 是主线程对象，仅 run() 属于子线程</td>
</tr>
<tr>
<td>是否有事件循环</td>
<td>✔️ 可启用（通过 <code>exec()</code>）</td>
<td>❌ 无事件循环</td>
</tr>
<tr>
<td>是否支持 moveToThread</td>
<td>✔️ 可绑定 <code>QObject</code> 对象</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td>是否支持信号槽机制</td>
<td>✔️ 可跨线程通信</td>
<td>❌ 默认不支持（需手动 hack）</td>
</tr>
<tr>
<td>适合用途</td>
<td>长期存在、复杂控制、协议通信</td>
<td>轻量任务、短时批处理</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、QThread-传统线程用法"><a href="#二、QThread-传统线程用法" class="headerlink" title="二、QThread 传统线程用法"></a>二、QThread 传统线程用法</h2><h3 id="1-创建逻辑对象与线程"><a href="#1-创建逻辑对象与线程" class="headerlink" title="1. 创建逻辑对象与线程"></a>1. 创建逻辑对象与线程</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">Worker* worker = <span class="keyword">new</span> Worker;  <span class="comment">//任务对象，可以被绑定到子线程的逻辑对象，用于执行实际任务</span></span><br><span class="line">QThread* thread = <span class="keyword">new</span> QThread;  <span class="comment">//子线程对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迁移对象</span></span><br><span class="line">worker-&gt;moveToThread(thread); <span class="comment">//将任务对象迁移至子线程对象，worker可以为创建线程的this对象本身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号槽连接：</span></span><br><span class="line">	<span class="comment">//当线程启动时自动调用工作对象的任务函数 doWork()</span></span><br><span class="line">connect(thread, &amp;<span class="attribute">QThread</span>::started, worker, &amp;<span class="attribute">Worker</span>::doWork); </span><br><span class="line">	<span class="comment">//当工作对象发出 finished 信号时，通知线程退出事件循环</span></span><br><span class="line">connect(worker, &amp;<span class="attribute">Worker</span>::finished, thread, &amp;<span class="attribute">QThread</span>::quit);</span><br><span class="line">	<span class="comment">//当线程退出后，销毁 QThread 对象</span></span><br><span class="line">connect(thread, &amp;<span class="attribute">QThread</span>::finished, thread, &amp;<span class="attribute">QThread</span>::deleteLater);</span><br><span class="line">	<span class="comment">//当工作完成，自动销毁 worker 对象</span></span><br><span class="line">connect(worker, &amp;<span class="attribute">Worker</span>::finished, worker, &amp;<span class="attribute">QObject</span>::deleteLater);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">thread-&gt;start();</span><br></pre></td></tr></table></figure>

<p><code>QThread</code> 是 Qt 框架中用于<strong>创建和管理子线程</strong>的类，本质上是<strong>一个线程控制器</strong>。</p>
<ul>
<li>它自身不是用来写任务逻辑的</li>
<li>也不建议重写 <code>QThread::run()</code> 来做事</li>
<li>推荐做法是：<strong>将逻辑类（QObject）通过 <code>moveToThread()</code> 移到 <code>QThread</code> 中运行</strong></li>
</ul>
<h3 id="✅-特点"><a href="#✅-特点" class="headerlink" title="✅ 特点"></a>✅ 特点</h3><ul>
<li>逻辑对象可以用 <code>moveToThread()</code> 迁移至线程中运行</li>
<li>支持完整事件循环：定时器、信号槽、异步操作</li>
<li>适合长期保持运行、状态驱动的任务（如协议连接、设备通讯）</li>
</ul>
<hr>
<h2 id="三、线程池-QThreadPool-QRunnable-机制"><a href="#三、线程池-QThreadPool-QRunnable-机制" class="headerlink" title="三、线程池 QThreadPool + QRunnable 机制"></a>三、线程池 QThreadPool + QRunnable 机制</h2><h3 id="✅-基本结构"><a href="#✅-基本结构" class="headerlink" title="✅ 基本结构"></a>✅ 基本结构</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">class <span class="attribute">MyTask</span> : public <span class="title">QRunnable</span> &#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">    <span class="keyword">void</span> run() <span class="title">override</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的代码将在线程池中某个线程执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="attribute">QThreadPool</span>::globalInstance()-&gt;start(<span class="keyword">new</span> MyTask);</span><br></pre></td></tr></table></figure>

<h3 id="✅-特点-1"><a href="#✅-特点-1" class="headerlink" title="✅ 特点"></a>✅ 特点</h3><ul>
<li><p>无事件循环，不能使用信号槽、moveToThread</p>
</li>
<li><p>任务函数 run() 运行于子线程</p>
</li>
<li><p>非 QObject 类，仅适合一次性短任务处理</p>
</li>
</ul>
<h3 id="📌重点"><a href="#📌重点" class="headerlink" title="📌重点"></a>📌重点</h3><ul>
<li><p>run()函数内部才属于子线程，MyTask本身并不属于子线程！</p>
</li>
<li><p>run()函数内部调用任何属于MyTask构造函数内构建的对象，都属于非法访问！</p>
</li>
<li><p>run()函数内部可以调用MyTask.h声明的基本数据类型，这是被允许的！</p>
</li>
</ul>
<hr>
<h2 id="四、主线程对象的访问与-QMetaObject-invokeMethod"><a href="#四、主线程对象的访问与-QMetaObject-invokeMethod" class="headerlink" title="四、主线程对象的访问与 QMetaObject::invokeMethod"></a>四、主线程对象的访问与 QMetaObject::invokeMethod</h2><h3 id="✅-语法结构"><a href="#✅-语法结构" class="headerlink" title="✅ 语法结构"></a>✅ 语法结构</h3><p>无返回值多参调用：</p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="attribute">QMetaObject</span>::invokeMethod(mainObj, <span class="string">&quot;update&quot;</span>, </span><br><span class="line">                          <span class="attribute">Qt</span>::QueuedConnection,</span><br><span class="line">                          Q_ARG(QString, <span class="string">&quot;参数一&quot;</span>),</span><br><span class="line">                          Q_ARG(QString, <span class="string">&quot;参数二&quot;</span>),</span><br><span class="line">                          Q_ARG(<span class="built_in">int</span>, <span class="number">3</span>),</span><br><span class="line">                          Q_ARG(float, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>有返回值调用：</p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QString result;</span><br><span class="line"><span class="built_in">bool</span> success = <span class="attribute">QMetaObject</span>::invokeMethod(targetObj, <span class="string">&quot;getProcessedString&quot;</span>,</span><br><span class="line">                                         <span class="attribute">Qt</span>::BlockingQueuedConnection,</span><br><span class="line">                                         Q_RETURN_ARG(QString, result),</span><br><span class="line">                                         Q_ARG(QString, <span class="string">&quot;参数一&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="✅-参数解析"><a href="#✅-参数解析" class="headerlink" title="✅ 参数解析"></a>✅ 参数解析</h3><table>
<thead>
<tr>
<th>参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>mainObj</code></td>
<td align="left">主线程中的 QObject 派生对象指针</td>
</tr>
<tr>
<td><code>&quot;update&quot;</code></td>
<td align="left">要调用的槽函数名<br />（必须是 slot 或 Q_INVOKABLE 即函数被 public slots: 声明 ）</td>
</tr>
<tr>
<td><code>Qt::QueuedConnection</code></td>
<td align="left">跨线程排队执行</td>
</tr>
<tr>
<td><code>Q_ARG(QString, result)</code></td>
<td align="left">参数类型和值封装</td>
</tr>
<tr>
<td><code>Qt::BlockingQueuedConnection</code></td>
<td align="left">跨线程排队执行  带返回值</td>
</tr>
<tr>
<td><code>Q_RETURN_ARG(QString, result)</code></td>
<td align="left">返回值类型和值封装</td>
</tr>
</tbody></table>
<h3 id="✅-执行原理"><a href="#✅-执行原理" class="headerlink" title="✅ 执行原理"></a>✅ 执行原理</h3><ul>
<li>子线程调用 <code>invokeMethod</code></li>
<li>Qt 检测 <code>mainObj</code> 所属线程（主线程）</li>
<li>将调用请求放入 <code>mainObj</code> 所属线程的事件队列</li>
<li>最终由主线程事件循环执行此方法</li>
</ul>
<h3 id="✅-示例"><a href="#✅-示例" class="headerlink" title="✅ 示例"></a>✅ 示例</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">class <span class="attribute">MyTask</span> : public <span class="title">QRunnable</span> &#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">    MyTask(QObject* target) : mainObj(target) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> run() <span class="title">override</span> &#123;</span><br><span class="line">        <span class="attribute">QMetaObject</span>::invokeMethod(mainObj, <span class="string">&quot;updateUI&quot;</span>,</span><br><span class="line">                                  <span class="attribute">Qt</span>::QueuedConnection,</span><br><span class="line">                                  Q_ARG(QString, <span class="string">&quot;任务完成&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attribute">private</span>:</span><br><span class="line">    QObject* mainObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="📌重点-1"><a href="#📌重点-1" class="headerlink" title="📌重点"></a>📌重点</h3><ul>
<li>mainObj属于主线程，QMetaObject::invokeMethod存在于子线程仅声明了mainObj对象，不属于直接调用，并不会触发报错。</li>
<li>在 <code>run()</code> 中你只是使用它的地址调用 <code>invokeMethod</code>，实际执行仍在主线程。</li>
</ul>
<hr>
<h2 id="五、线程安全性说明"><a href="#五、线程安全性说明" class="headerlink" title="五、线程安全性说明"></a>五、线程安全性说明</h2><h3 id="✅-子线程中可安全操作："><a href="#✅-子线程中可安全操作：" class="headerlink" title="✅ 子线程中可安全操作："></a>✅ 子线程中可安全操作：</h3><ul>
<li>局部基本类型变量（int, float, QString 等）</li>
<li>不与其他线程共享的私有数据</li>
</ul>
<h3 id="⚠️-需要加锁的情况："><a href="#⚠️-需要加锁的情况：" class="headerlink" title="⚠️ 需要加锁的情况："></a>⚠️ 需要加锁的情况：</h3><ul>
<li>全局变量</li>
<li>多线程共享的成员变量（static、引用）</li>
</ul>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">mutex.lock();</span><br><span class="line">sharedData += <span class="number">1</span>;</span><br><span class="line">mutex.unlock();</span><br></pre></td></tr></table></figure>

<h3 id="❌-严禁子线程中直接操作主线程-UI："><a href="#❌-严禁子线程中直接操作主线程-UI：" class="headerlink" title="❌ 严禁子线程中直接操作主线程 UI："></a>❌ 严禁子线程中直接操作主线程 UI：</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">ui-&gt;label-&gt;setText(<span class="string">&quot;XXX&quot;</span>);  <span class="comment">// ❌ 不允许（线程不安全）</span></span><br></pre></td></tr></table></figure>

<p>请使用 <code>invokeMethod</code> 或信号槽跨线程通知主线程操作 UI。</p>
<hr>
<h2 id="六、信号槽-跨线程通信-要点声明"><a href="#六、信号槽-跨线程通信-要点声明" class="headerlink" title="六、信号槽 跨线程通信 要点声明"></a>六、信号槽 跨线程通信 要点声明</h2><h3 id="✅-跨线程通信时，须使用-Qt-QueuedConnection-强制排队调用槽函数"><a href="#✅-跨线程通信时，须使用-Qt-QueuedConnection-强制排队调用槽函数" class="headerlink" title="✅ 跨线程通信时，须使用 Qt::QueuedConnection 强制排队调用槽函数"></a>✅ 跨线程通信时，须使用 Qt::QueuedConnection 强制排队调用槽函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect(worker, &amp;Worker::resultReady,</span><br><span class="line">        mainWindow, &amp;MainWindow::updateUI,</span><br><span class="line">        Qt::QueuedConnection);  // 强制主线程中执行</span><br></pre></td></tr></table></figure>

<h3 id="⚠️-为什么需要强制排队："><a href="#⚠️-为什么需要强制排队：" class="headerlink" title="⚠️ 为什么需要强制排队："></a>⚠️ 为什么需要强制排队：</h3><ul>
<li><code>Qt::AutoConnection</code> 默认行为不确定：线程未启动或迁移失败时，可能槽函数仍在错误线程中执行</li>
<li><code>Qt::QueuedConnection</code> 可确保槽函数<strong>总是在线程归属对象的线程中执行</strong>（如主线程）</li>
<li>避免崩溃、死锁、UI 线程访问冲突</li>
</ul>
<h3 id="✅-常见连接类型解释"><a href="#✅-常见连接类型解释" class="headerlink" title="✅ 常见连接类型解释"></a>✅ 常见连接类型解释</h3><table>
<thead>
<tr>
<th>连接类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>Qt::AutoConnection</code></td>
<td>自动判断是否跨线程，默认值（⚠️不安全）</td>
</tr>
<tr>
<td><code>Qt::DirectConnection</code></td>
<td>立即在当前线程调用槽函数（⚠️跨线程风险）</td>
</tr>
<tr>
<td><code>Qt::QueuedConnection</code></td>
<td>投递到目标线程事件队列执行（✔️推荐）</td>
</tr>
<tr>
<td><code>Qt::BlockingQueuedConnection</code></td>
<td>阻塞当前线程直到槽函数执行完（⚠️容易死锁）</td>
</tr>
<tr>
<td><code>Qt::UniqueConnection</code></td>
<td>防止重复连接，可与其他连接类型组合使用</td>
</tr>
</tbody></table>
<hr>
<h2 id="七、总结建议"><a href="#七、总结建议" class="headerlink" title="七、总结建议"></a>七、总结建议</h2><ul>
<li><strong>协议接入、串口通信、长期任务：</strong> 推荐使用 <code>QThread + QObject + moveToThread</code> 模式</li>
<li><strong>高并发短时任务，如数据块计算、图像处理：</strong> 推荐使用 <code>QThreadPool + QRunnable</code></li>
<li>**跨线程通信：**统一用 <code>信号槽</code> 或 <code>QMetaObject::invokeMethod(Qt::QueuedConnection)</code></li>
</ul>
<p>二者可以在项目中混合使用，按照任务特点灵活选型。</p>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>QT</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式详解（C++）</title>
    <url>/2025/04/25/qt_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>在 C++ 的全局状态管理中，单例模式是非常重要的解决方案，保证其线程的安全性尤为重要，本文介绍了单例模式的多种形式，类比了不同形式的差异。</p>
</blockquote>
<hr>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点。</p>
<p>适用于：</p>
<ul>
<li>配置管理器</li>
<li>日志管理器</li>
<li>线程池</li>
<li>数据库连接池</li>
<li>全局唯一资源等</li>
</ul>
<hr>
<h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><h3 id="1-饿汉式（线程安全，类加载即实例化）"><a href="#1-饿汉式（线程安全，类加载即实例化）" class="headerlink" title="1. 饿汉式（线程安全，类加载即实例化）"></a>1. 饿汉式（线程安全，类加载即实例化）</h3><p><code>Singleton.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取全局唯一实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造与赋值，防止复制</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有化，防止外部实例化</span></span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数私有化，防止被 delete</span></span><br><span class="line">    ~<span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员对象声明（注意这里只是声明）</span></span><br><span class="line">    <span class="type">static</span> Singleton instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SINGLETON_H</span></span></span><br></pre></td></tr></table></figure>
<p><code>Singleton.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义并初始化静态成员变量</span></span><br><span class="line">Singleton Singleton::instance;</span><br><span class="line"></span><br><span class="line">Singleton::<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 构造函数调用\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 析构函数调用\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton&amp; <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：线程安全，简单</p>
<p><strong>缺点</strong>：类加载时即创建，浪费资源</p>
<hr>
<h3 id="2-懒汉式（延迟加载-线程不安全）"><a href="#2-懒汉式（延迟加载-线程不安全）" class="headerlink" title="2. 懒汉式（延迟加载 + 线程不安全）"></a>2. 懒汉式（延迟加载 + 线程不安全）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance)</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：多线程同时访问时可能创建多个实例</p>
<hr>
<h3 id="3-懒汉式-加锁（线程安全）"><a href="#3-懒汉式-加锁（线程安全）" class="headerlink" title="3. 懒汉式 + 加锁（线程安全）"></a>3. 懒汉式 + 加锁（线程安全）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!instance)</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mtx;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-双重检查锁定（DCL）"><a href="#4-双重检查锁定（DCL）" class="headerlink" title="4. 双重检查锁定（DCL）"></a>4. 双重检查锁定（DCL）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!instance)</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mtx;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：C++11 之后 <code>std::atomic</code> 可用于防止重排序</p>
<hr>
<h3 id="5-C-11-静态局部变量（推荐）"><a href="#5-C-11-静态局部变量（推荐）" class="headerlink" title="5. C++11 静态局部变量（推荐）"></a>5. C++11 静态局部变量（推荐）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// C++11 线程安全  </span></span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">//只会初始化一次（即第一次调用时）</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、线程安全的措施"><a href="#三、线程安全的措施" class="headerlink" title="三、线程安全的措施"></a>三、线程安全的措施</h2><ul>
<li>使用 <code>std::mutex</code> + 加锁</li>
<li>C++11 <code>static</code> 局部变量（推荐）</li>
<li><code>std::call_once</code> + <code>std::once_flag</code>（高级方案）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, []()&#123; instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>(); &#125;);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::once_flag Singleton::flag;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、子线程中使用单例对象"><a href="#四、子线程中使用单例对象" class="headerlink" title="四、子线程中使用单例对象"></a>四、子线程中使用单例对象</h2><p>在大多数情况下，你可以直接通过 <code>Singleton::getInstance()</code> 获取单例对象并在子线程中使用它，<strong>不需要</strong>调用 <code>moveToThread()</code>。</p>
<ol>
<li><strong>单例对象本身不绑定到任何线程</strong>，它是一个全局唯一的实例。</li>
<li>创建时<strong>线程安全性</strong>由单例本身实现保证（如前面提到的 <code>std::once_flag</code> 或静态局部变量）。</li>
<li><strong>如果单例的成员函数是线程安全的</strong>（例如使用互斥锁保护共享数据），则可以直接在子线程中调用。</li>
</ol>
<hr>
<h2 id="五、成员函数是否加锁，取决于你是否有共享资源写操作⚠️"><a href="#五、成员函数是否加锁，取决于你是否有共享资源写操作⚠️" class="headerlink" title="五、成员函数是否加锁，取决于你是否有共享资源写操作⚠️"></a>五、成员函数是否加锁，取决于你是否有<strong>共享资源写操作</strong>⚠️</h2><p>下面是重点！</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>是否需要加锁</th>
</tr>
</thead>
<tbody><tr>
<td>只读成员数据</td>
<td>❌ 不需要加锁</td>
</tr>
<tr>
<td>多线程并发修改成员数据</td>
<td>✅ 必须加锁</td>
</tr>
<tr>
<td>多线程调用函数内创建的局部变量（栈变量）</td>
<td>❌ 不需要加锁</td>
</tr>
<tr>
<td>调用 Qt 信号槽机制、事件循环的成员函数</td>
<td>⚠️ 需要考虑线程上下文是否一致</td>
</tr>
</tbody></table>
<h2 id="六、总结对比表"><a href="#六、总结对比表" class="headerlink" title="六、总结对比表"></a>六、总结对比表</h2><table>
<thead>
<tr>
<th>实现方式</th>
<th>是否线程安全</th>
<th>是否延迟加载</th>
<th>实现复杂度</th>
<th>推荐等级</th>
</tr>
</thead>
<tbody><tr>
<td>饿汉式</td>
<td>是</td>
<td>否</td>
<td>简单</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td>懒汉式</td>
<td>否</td>
<td>是</td>
<td>简单</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td>懒汉式加锁</td>
<td>是</td>
<td>是</td>
<td>中</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>双重检查锁定</td>
<td>是</td>
<td>是</td>
<td>中等偏高</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>C++11 局部静态</td>
<td>是</td>
<td>是</td>
<td>最简单</td>
<td>★★★★★</td>
</tr>
</tbody></table>
<hr>
<h2 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a>七、注意事项</h2><ul>
<li>单例构造函数必须私有，防止外部创建</li>
<li>禁用拷贝构造和赋值运算符，防止复制</li>
<li>多线程场景中务必考虑线程安全</li>
<li>Qt 中如涉及信号槽及 QObject，则使用线程迁移要格外小心</li>
</ul>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 中实现全局数据与函数的几种方式</title>
    <url>/2025/04/24/qt_%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>在 Qt 或 C++ 开发中，全局状态管理是较常见的需求。本文将总结几种常见的全局数据与函数管理方式，并详细说明各自的使用场景、优缺点和示例。</p>
</blockquote>
<hr>
<h2 id="✅-总览：Qt-中全局数据-函数的几种使用方式"><a href="#✅-总览：Qt-中全局数据-函数的几种使用方式" class="headerlink" title="✅ 总览：Qt 中全局数据&#x2F;函数的几种使用方式"></a>✅ 总览：Qt 中全局数据&#x2F;函数的几种使用方式</h2><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>是否线程安全</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody><tr>
<td>1. <code>extern</code> 全局变量</td>
<td>使用 <code>extern</code> 声明和定义</td>
<td>❌ 手动加锁</td>
<td>⚠️ 一般</td>
</tr>
<tr>
<td>2. 静态类成员变量</td>
<td><code>static</code> 成员归属类本身</td>
<td>❌ 手动加锁</td>
<td>✅ 推荐</td>
</tr>
<tr>
<td>3. 单例模式（Singleton）</td>
<td>控制对象唯一实例，全局访问</td>
<td>✅ 可加锁</td>
<td>✅ 强烈推荐</td>
</tr>
<tr>
<td>4. <code>Q_GLOBAL_STATIC</code></td>
<td>Qt 宏封装线程安全静态实例</td>
<td>✅ 线程安全</td>
<td>✅ 推荐</td>
</tr>
<tr>
<td>5. <code>qApp</code> 全局访问</td>
<td>在 QApplication 子类中挂载数据</td>
<td>⚠️ 依赖 GUI</td>
<td>⚠️ 有限</td>
</tr>
<tr>
<td>6. 命名空间变量&#x2F;函数</td>
<td>使用 <code>namespace</code> 组织函数&#x2F;变量</td>
<td>❌ 手动加锁</td>
<td>✅ 推荐</td>
</tr>
<tr>
<td>7. 工具函数</td>
<td>独立工具函数，Stateless 操作</td>
<td>✅</td>
<td>✅ 推荐</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-1-使用-extern-声明全局变量-对象"><a href="#✅-1-使用-extern-声明全局变量-对象" class="headerlink" title="✅ 1. 使用 extern 声明全局变量&#x2F;对象"></a>✅ 1. 使用 <code>extern</code> 声明全局变量&#x2F;对象</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// globaldata.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;globalclass.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalCounter; <span class="comment">//变量</span></span><br><span class="line"><span class="keyword">extern</span> GlobalClass *globalClass; <span class="comment">//自定义类类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// globaldata.cpp</span></span><br><span class="line"><span class="type">int</span> globalCounter = <span class="number">0</span>;</span><br><span class="line">GlobalClass* globalClass = <span class="keyword">new</span> GlobalClass;</span><br></pre></td></tr></table></figure>

<p><code>extern</code> 声明的全局变量 <strong>不需要写在 <code>main()</code> 函数 文件所在位置</strong>，它可以出现在<strong>所有需要使用这个变量的文件中的全局作用域</strong>，变量的<strong>定义只能有一个</strong>，通常放在一个 <code>.cpp</code> 文件中。</p>
<p>⚠️extern声明的全局变量是线程不安全的，尽量加锁使用</p>
<hr>
<h2 id="✅-2-静态类成员"><a href="#✅-2-静态类成员" class="headerlink" title="✅ 2. 静态类成员"></a>✅ 2. 静态类成员</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppState</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> AppState::counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppState::reset</span><span class="params">()</span> </span>&#123; counter = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-3-单例模式（Singleton）"><a href="#✅-3-单例模式（Singleton）" class="headerlink" title="✅ 3. 单例模式（Singleton）"></a>✅ 3. 单例模式（Singleton）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GlobalManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> GlobalManager&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> GlobalManager inst;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">GlobalManager</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Q_DISABLE_COPY</span>(GlobalManager)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GlobalManager::<span class="built_in">instance</span>().counter++;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-4-使用-Qt-的-Q-GLOBAL-STATIC"><a href="#✅-4-使用-Qt-的-Q-GLOBAL-STATIC" class="headerlink" title="✅ 4. 使用 Qt 的 Q_GLOBAL_STATIC"></a>✅ 4. 使用 Qt 的 <code>Q_GLOBAL_STATIC</code></h2><p><code>Q_GLOBAL_STATIC</code> 是 Qt 提供的一个宏，用于 <strong>创建线程安全的、延迟初始化的全局单例对象</strong>。<br> 它可以在多个 <code>.cpp</code> 文件中安全使用，避免传统静态对象的初始化顺序问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Q_GLOBAL_STATIC</span>(QMap&lt;QString, <span class="type">int</span>&gt;, globalMap)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line">(*<span class="built_in">globalMap</span>())[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>; </span><br><span class="line"><span class="comment">//1：括号都是必须的，globalMap() 是一个函数调用，返回的是 QMap&lt;QString, int&gt;* 类型的指针。</span></span><br><span class="line"><span class="comment">//2：*globalMap() 把这个指针解引用，变成 QMap&lt;QString, int&gt;&amp;。</span></span><br><span class="line"><span class="comment">//3：外层括号 (*globalMap()) 是必须加的，否则会出错。</span></span><br><span class="line"><span class="comment">//4：(*globalMap())[&quot;apple&quot;] 访问或创建键 &quot;apple&quot; 的值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>⚠️<code>Q_GLOBAL_STATIC</code>创建对象时， <strong>不能附带构造函数参数</strong>，它只支持默认构造函数。如果需要附带参数初始化全局单例，应该用 <strong><code>Q_GLOBAL_STATIC_WITH_ARGS</code></strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Q_GLOBAL_STATIC</span>(GlobalClass, globalClass) <span class="comment">//GlobalClass 必须有默认构造函数。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="built_in">GlobalClass</span>()-&gt;<span class="built_in">myfunction</span>(<span class="string">&quot;实参&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-5-QApplication-子类-宏-方式"><a href="#✅-5-QApplication-子类-宏-方式" class="headerlink" title="✅ 5. QApplication 子类+宏 方式"></a>✅ 5. QApplication 子类+宏 方式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写QApplication</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQApplication</span> : <span class="keyword">public</span> QApplication &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QString userToken;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数初始化构造MyQApplication</span></span><br><span class="line"><span class="function">MyApp <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前项目唯一的 MyQApplication 实例 ,定义为宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> myApp (static_cast<span class="string">&lt;MyQApplication*&gt;</span>(QCoreApplication::instance()))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用宏全局调用</span></span><br><span class="line">myApp-&gt;userToken = <span class="string">&quot;abc123&quot;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-6-命名空间方式"><a href="#✅-6-命名空间方式" class="headerlink" title="✅ 6. 命名空间方式"></a>✅ 6. 命名空间方式</h2><p>⚠️仅支持 C++17 及以上</p>
<p><strong>inline variables</strong>（内联变量） —— 允许在头文件中定义且只会有一个实例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Global &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; counter = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Global::counter++;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-7-全局工具函数"><a href="#✅-7-全局工具函数" class="headerlink" title="✅ 7. 全局工具函数"></a>✅ 7. 全局工具函数</h2><p>⚠️仅支持 C++17 及以上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Util &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> QString&amp; msg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;[LOG]&quot;</span> &lt;&lt; msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Util::<span class="built_in">log</span>(<span class="string">&quot;App started&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📌-总结建议"><a href="#📌-总结建议" class="headerlink" title="📌 总结建议"></a>📌 总结建议</h2><ul>
<li>简单数据可用 <code>extern + QMutex</code>；</li>
<li>多模块共享用 <code>static</code> 成员；</li>
<li>全局复杂状态推荐用单例；</li>
<li>轻量线程安全首选 <code>Q_GLOBAL_STATIC</code>；</li>
<li>GUI 层次可在 QApplication 挂载；</li>
<li>工具函数、常量组织建议用 <code>namespace</code>。</li>
</ul>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt/C++ 项目数据库选型与 SQLite 使用指南</title>
    <url>/2025/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B%E4%B8%8ESQLite%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>本文简单介绍了项目数据库的选择，并详细介绍了SQLite的使用和注意事项。</p>
</blockquote>
<hr>
<h2 id="📌-一、常见数据库选型对比"><a href="#📌-一、常见数据库选型对比" class="headerlink" title="📌 一、常见数据库选型对比"></a>📌 一、常见数据库选型对比</h2><table>
<thead>
<tr>
<th>数据库</th>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SQLite</strong></td>
<td>嵌入式本地库</td>
<td>轻量、无服务、单文件存储、Qt原生支持、易于部署</td>
<td>写时锁全库、不适合高并发写、无远程访问支持</td>
<td>单机&#x2F;嵌入式&#x2F;工控设备&#x2F;小数据量</td>
</tr>
<tr>
<td><strong>MySQL</strong></td>
<td>服务器数据库</td>
<td>支持多用户并发、文档丰富、跨平台、社区活跃</td>
<td>需独立服务、需开放端口、防火墙设置</td>
<td>中大型系统、Web后端、数据统一管理</td>
</tr>
<tr>
<td><strong>MariaDB</strong></td>
<td>MySQL分支</td>
<td>与MySQL兼容、开源自由度更高</td>
<td>同MySQL</td>
<td>MySQL 替代品</td>
</tr>
<tr>
<td><strong>PostgreSQL</strong></td>
<td>服务器数据库</td>
<td>SQL功能强大、支持复杂查询、事务安全性高、扩展性好</td>
<td>安装复杂度稍高、资源占用略大</td>
<td>金融&#x2F;分析&#x2F;高并发&#x2F;复杂数据系统</td>
</tr>
<tr>
<td><strong>MongoDB</strong></td>
<td>文档数据库</td>
<td>Schema灵活、支持JSON、开发迅速</td>
<td>非SQL语法、事务支持有限、不适合强一致性场景</td>
<td>IoT&#x2F;日志存储&#x2F;原型开发&#x2F;数据结构不固定</td>
</tr>
<tr>
<td><strong>Redis</strong></td>
<td>内存数据库</td>
<td>超高速、支持队列、适合作为缓存层</td>
<td>数据量受内存限制、非关系型、不适合主数据持久化</td>
<td>实时缓存&#x2F;队列系统&#x2F;辅助数据库</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-二、SQLite-多线程访问机制与使用建议"><a href="#✅-二、SQLite-多线程访问机制与使用建议" class="headerlink" title="✅ 二、SQLite 多线程访问机制与使用建议"></a>✅ 二、SQLite 多线程访问机制与使用建议</h2><h3 id="SQLite-有三种线程模式，可以通过编译选项设置："><a href="#SQLite-有三种线程模式，可以通过编译选项设置：" class="headerlink" title="SQLite 有三种线程模式，可以通过编译选项设置："></a>SQLite 有三种线程模式，可以通过编译选项设置：</h3><h3 id="1-1-Single-thread（单线程模式）"><a href="#1-1-Single-thread（单线程模式）" class="headerlink" title="1.1 Single-thread（单线程模式）"></a>1.1 Single-thread（单线程模式）</h3><ul>
<li>编译宏：<code>SQLITE_THREADSAFE=0</code></li>
<li>所有互斥锁禁用，SQLite 只能在一个线程中使用。</li>
<li>无线程安全性。</li>
</ul>
<h3 id="1-2-Multi-thread（多线程模式）"><a href="#1-2-Multi-thread（多线程模式）" class="headerlink" title="1.2 Multi-thread（多线程模式）"></a>1.2 Multi-thread（多线程模式）</h3><ul>
<li>编译宏：<code>SQLITE_THREADSAFE=2</code></li>
<li>多线程可调用 SQLite API，但<strong>同一连接对象不能被多个线程同时使用</strong>。</li>
</ul>
<h3 id="1-3-Serialized（序列化模式）✅-默认模式"><a href="#1-3-Serialized（序列化模式）✅-默认模式" class="headerlink" title="1.3 Serialized（序列化模式）✅ 默认模式"></a>1.3 Serialized（序列化模式）✅ 默认模式</h3><ul>
<li>编译宏：<code>SQLITE_THREADSAFE=1</code></li>
<li>所有 API 均加锁，可安全在多个线程中使用同一个连接对象（<code>sqlite3*</code>）。</li>
<li>内部自动加锁，线程安全。</li>
</ul>
<h3 id="✅-推荐使用方式"><a href="#✅-推荐使用方式" class="headerlink" title="✅ 推荐使用方式"></a>✅ 推荐使用方式</h3><ul>
<li>多个线程共享一个 SQLite 连接时，并使用互斥锁保证线程安全。</li>
<li>也可使用 <strong>多个 <code>.db</code> 文件</strong> 拆分业务实现“伪并发”。</li>
</ul>
<h3 id="🔐-QMutex-加锁方案"><a href="#🔐-QMutex-加锁方案" class="headerlink" title="🔐 QMutex 加锁方案"></a>🔐 QMutex 加锁方案</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMutex dbMutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeThreadSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;dbMutex)</span></span>;  <span class="comment">// 自动加锁与释放</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;INSERT INTO logs (msg) VALUES (&#x27;测试数据&#x27;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="✅-三、Qt-中使用-SQLite-的基本示例"><a href="#✅-三、Qt-中使用-SQLite-的基本示例" class="headerlink" title="✅ 三、Qt 中使用 SQLite 的基本示例"></a>✅ 三、Qt 中使用 SQLite 的基本示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;data/mydata.db&quot;</span>);</span><br><span class="line">db.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">QSqlQuery query;</span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;CREATE TABLE IF NOT EXISTS logs (id INTEGER PRIMARY KEY, msg TEXT)&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="✅-四、Qt-中使用-SQLite-的高级示例"><a href="#✅-四、Qt-中使用-SQLite-的高级示例" class="headerlink" title="✅ 四、Qt 中使用 SQLite 的高级示例"></a>✅ 四、Qt 中使用 SQLite 的高级示例</h2><h3 id="1：创建链接基类SQLiteHelper"><a href="#1：创建链接基类SQLiteHelper" class="headerlink" title="1：创建链接基类SQLiteHelper"></a>1：创建链接基类SQLiteHelper</h3><p><code>SQLiteHelper.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLITEHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITEHELPER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief SQLiteHelper</span></span><br><span class="line"><span class="comment"> * 用于管理 SQLite 数据库的连接、表操作、数据清理等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLiteHelper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SQLiteHelper</span>();     <span class="comment">// 构造函数：初始化驱动和默认参数</span></span><br><span class="line">    ~<span class="built_in">SQLiteHelper</span>();    <span class="comment">// 析构函数：关闭数据库连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库连接与控制</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConnectDB</span><span class="params">()</span></span>;                         <span class="comment">// 创建或复用数据库连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">open</span><span class="params">()</span></span>;                              <span class="comment">// 打开数据库</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;                             <span class="comment">// 关闭数据库</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Disconnect</span><span class="params">()</span></span>;                        <span class="comment">// 关闭并移除连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeDatabase</span><span class="params">()</span></span>;                    <span class="comment">// 从连接池中移除连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置设置</span></span><br><span class="line">    <span class="comment">// 设置数据库文件名和连接名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDbConnectName</span><span class="params">(<span class="type">const</span> QString&amp; dbName, <span class="type">const</span> QString&amp; linkName)</span></span>;  </span><br><span class="line">    <span class="comment">// 设置数据库连接参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDbConnectPara</span><span class="params">(<span class="type">const</span> QString&amp; driverName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QString&amp; hostName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QString&amp; userName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QString&amp; password)</span></span>;                          </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表结构操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CreateTable</span><span class="params">(<span class="type">const</span> QString&amp; strCreate)</span></span>;     <span class="comment">// 执行建表 SQL</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">QueryTableHave</span><span class="params">(<span class="type">const</span> QString&amp; tableName)</span></span>;    <span class="comment">// 查询表是否存在</span></span><br><span class="line">    <span class="comment">// 查询字段是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">QueryTableFieldHave</span><span class="params">(<span class="type">const</span> QString&amp; tableName, <span class="type">const</span> QString&amp; fieldName)</span></span>;</span><br><span class="line">    <span class="comment">// 添加字段</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AddFieldToTable</span><span class="params">(<span class="type">const</span> QString&amp; tableName, </span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> QString&amp; fieldName,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> QString&amp; fieldType)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearData</span><span class="params">(<span class="type">const</span> QString&amp; table)</span></span>;	<span class="comment">// 清空表中所有数据</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">QueryTotal</span><span class="params">(<span class="type">const</span> QString&amp; table)</span></span>;	<span class="comment">// 查询表中记录总数</span></span><br><span class="line">    <span class="comment">// 删除前 N 条数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DeleteData</span><span class="params">(<span class="type">const</span> QString&amp; table, <span class="type">const</span> QString&amp; column, <span class="type">int</span> count)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QSqlDatabase m_db;          <span class="comment">// 数据库对象</span></span><br><span class="line">    QMutex m_mutex;             <span class="comment">// 线程互斥锁（用于多线程访问保护）</span></span><br><span class="line"></span><br><span class="line">    QString m_dbName;           <span class="comment">// 数据库文件名</span></span><br><span class="line">    QString m_linkName;         <span class="comment">// 数据库连接名</span></span><br><span class="line">    QString m_driverName;       <span class="comment">// 驱动名（如 QSQLITE）</span></span><br><span class="line">    QString m_userName;         <span class="comment">// 用户名（通常为空）</span></span><br><span class="line">    QString m_password;         <span class="comment">// 密码（通常为空）</span></span><br><span class="line">    QString m_hostName;         <span class="comment">// 主机名（本地 SQLite 通常为空）</span></span><br><span class="line">    <span class="type">int</span> m_port;                 <span class="comment">// 端口（本地 SQLite 通常为 -1）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SQLITEHELPER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>SQLiteHelper.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlitehelper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDir&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：初始化数据库驱动类型和连接参数</span></span><br><span class="line">SQLiteHelper::<span class="built_in">SQLiteHelper</span>()</span><br><span class="line">    : <span class="built_in">m_driverName</span>(<span class="string">&quot;QSQLITE&quot;</span>), <span class="built_in">m_userName</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_password</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_hostName</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_port</span>(<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;支持的数据库驱动：&quot;</span> &lt;&lt; QSqlDatabase::<span class="built_in">drivers</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数：关闭数据库连接</span></span><br><span class="line">SQLiteHelper::~<span class="built_in">SQLiteHelper</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_db.<span class="built_in">isOpen</span>()) &#123;</span><br><span class="line">        m_db.<span class="built_in">close</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;%1 已关闭。&quot;</span>).<span class="built_in">arg</span>(m_linkName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库，如果已存在连接则复用，否则新建连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SQLiteHelper::ConnectDB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QSqlDatabase::<span class="built_in">contains</span>(m_linkName)) &#123;</span><br><span class="line">        m_db = QSqlDatabase::<span class="built_in">database</span>(m_linkName);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;连接 %1 仍在使用中。&quot;</span>).<span class="built_in">arg</span>(m_linkName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m_db = QSqlDatabase::<span class="built_in">addDatabase</span>(m_driverName, m_linkName);</span><br><span class="line">        m_db.<span class="built_in">setDatabaseName</span>(m_dbName);</span><br><span class="line">        m_db.<span class="built_in">setHostName</span>(m_hostName);</span><br><span class="line">        m_db.<span class="built_in">setPort</span>(m_port);</span><br><span class="line">        m_db.<span class="built_in">setUserName</span>(m_userName);</span><br><span class="line">        m_db.<span class="built_in">setPassword</span>(m_password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开数据库连接，若连接未打开则尝试打开</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SQLiteHelper::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_db.<span class="built_in">isOpen</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_db.<span class="built_in">open</span>()) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; m_db.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭数据库连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SQLiteHelper::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_db.<span class="built_in">isOpen</span>()) &#123;</span><br><span class="line">        m_db.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数据库连接池中移除指定连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SQLiteHelper::removeDatabase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSqlDatabase::<span class="built_in">removeDatabase</span>(m_linkName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断指定表是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SQLiteHelper::QueryTableHave</span><span class="params">(<span class="type">const</span> QString&amp; tableName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">open</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;数据库打开失败。&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_db.<span class="built_in">tables</span>().<span class="built_in">contains</span>(tableName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断指定表中是否存在指定字段</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SQLiteHelper::QueryTableFieldHave</span><span class="params">(<span class="type">const</span> QString&amp; tableName, <span class="type">const</span> QString&amp; fieldName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">open</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;数据库打开失败。&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(m_db)</span></span>;</span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;PRAGMA table_info(&quot;</span> + tableName + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;PRAGMA 查询失败：&quot;</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (query.<span class="built_in">next</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query.<span class="built_in">value</span>(<span class="string">&quot;name&quot;</span>).<span class="built_in">toString</span>() == fieldName)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行建表 SQL 语句</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SQLiteHelper::CreateTable</span><span class="params">(<span class="type">const</span> QString&amp; strCreate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">open</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;数据库打开失败。&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(m_db)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">prepare</span>(strCreate)) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;建表语句准备失败：&quot;</span> &lt;&lt; strCreate;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;建表执行失败：&quot;</span> &lt;&lt; strCreate;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;建表成功：&quot;</span> &lt;&lt; strCreate;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向表中添加新字段（如果不存在）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SQLiteHelper::AddFieldToTable</span><span class="params">(<span class="type">const</span> QString&amp; tableName, <span class="type">const</span> QString&amp; fieldName, <span class="type">const</span> QString&amp; fieldType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">open</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;数据库打开失败。&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">QueryTableFieldHave</span>(tableName, fieldName)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;字段已存在：&quot;</span> &lt;&lt; fieldName;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QString alterSql = <span class="built_in">QString</span>(<span class="string">&quot;ALTER TABLE %1 ADD COLUMN %2 %3&quot;</span>).<span class="built_in">arg</span>(tableName, fieldName, fieldType);</span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(m_db)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">exec</span>(alterSql)) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;添加字段失败：&quot;</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空指定表的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SQLiteHelper::ClearData</span><span class="params">(<span class="type">const</span> QString&amp; table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">open</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;数据库打开失败。&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QString sql = <span class="built_in">QString</span>(<span class="string">&quot;DELETE FROM %1&quot;</span>).<span class="built_in">arg</span>(table);</span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(m_db)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">prepare</span>(sql)) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;SQL 准备失败：&quot;</span> &lt;&lt; sql;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;清空表失败：&quot;</span> &lt;&lt; sql;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;表清空成功：&quot;</span> &lt;&lt; sql;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询指定表中数据总行数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SQLiteHelper::QueryTotal</span><span class="params">(<span class="type">const</span> QString&amp; table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">open</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    QString sql = <span class="built_in">QString</span>(<span class="string">&quot;SELECT COUNT(*) FROM %1&quot;</span>).<span class="built_in">arg</span>(table);</span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(m_db)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">prepare</span>(sql)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (query.<span class="built_in">exec</span>() &amp;&amp; query.<span class="built_in">next</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除表中前 count 条数据（按列升序）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SQLiteHelper::DeleteData</span><span class="params">(<span class="type">const</span> QString&amp; table, <span class="type">const</span> QString&amp; column, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">open</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    QString subQuery = <span class="built_in">QString</span>(<span class="string">&quot;(SELECT %1 FROM %2 ORDER BY %1 ASC LIMIT %3)&quot;</span>)</span><br><span class="line">        .<span class="built_in">arg</span>(column, table).<span class="built_in">arg</span>(count);</span><br><span class="line">    QString sql = <span class="built_in">QString</span>(<span class="string">&quot;DELETE FROM %1 WHERE %2 IN %3&quot;</span>).<span class="built_in">arg</span>(table, column, subQuery);</span><br><span class="line"></span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(m_db)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">prepare</span>(sql)) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;SQL 准备失败：&quot;</span> &lt;&lt; sql;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;删除数据失败：&quot;</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;数据删除成功：&quot;</span> &lt;&lt; sql;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开并移除数据库连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SQLiteHelper::Disconnect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">    QSqlDatabase::<span class="built_in">removeDatabase</span>(m_linkName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据库文件名和连接名，并检查文件是否存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SQLiteHelper::setDbConnectName</span><span class="params">(<span class="type">const</span> QString&amp; dbName, <span class="type">const</span> QString&amp; linkName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_dbName = dbName;</span><br><span class="line">    m_linkName = linkName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QFile::<span class="built_in">exists</span>(dbName)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; dbName &lt;&lt; <span class="string">&quot;文件存在&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; dbName &lt;&lt; <span class="string">&quot;文件不存在&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据库连接参数（驱动、主机、端口、用户名、密码）</span></span><br><span class="line"><span class="comment">// 在使用 SQLite 数据库时，连接时只需要指定数据库文件路径（setDatabaseName）就可以</span></span><br><span class="line"><span class="comment">//不需要配置用户名、密码、主机、端口等信息。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SQLiteHelper::setDbConnectPara</span><span class="params">(<span class="type">const</span> QString&amp; driverName, <span class="type">const</span> QString&amp; hostName, <span class="type">int</span> port, <span class="type">const</span> QString&amp; userName, <span class="type">const</span> QString&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_driverName = driverName;</span><br><span class="line">    m_userName   = userName;</span><br><span class="line">    m_password   = password;</span><br><span class="line">    m_hostName   = hostName;</span><br><span class="line">    m_port       = port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2：针对不同的数据库文件，创建不同的子类，作为链接"><a href="#2：针对不同的数据库文件，创建不同的子类，作为链接" class="headerlink" title="2：针对不同的数据库文件，创建不同的子类，作为链接"></a>2：针对不同的数据库文件，创建不同的子类，作为链接</h3><p><code>MyDatabaseDB.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDatabaseDB</span> : <span class="keyword">public</span> SQLiteHelper</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyDatabaseDB</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyDatabaseDB</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载连接（可设默认路径）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ConnectDB</span><span class="params">()</span></span>;        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表结构定义</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CreateTable_testTabel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 各类表操作函数（后续可添加）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InsertTo_testTable</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Update_testTable</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeleteFrom_testTable</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function">QList&lt;QVariantMap&gt; <span class="title">QueryAll_testTable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>MyDatabaseDB.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyDatabaseDB::<span class="built_in">MyDatabaseDB</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">MyDatabaseDB::~<span class="built_in">MyDatabaseDB</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDatabaseDB::ConnectDB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SQLiteHelper::<span class="built_in">ConnectDB</span>();  <span class="comment">//链接库等初始化操作</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CreateTable_testTabel</span>();  <span class="comment">// 初始化表</span></span><br><span class="line">    ...... <span class="comment">//其它表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyDatabaseDB::CreateTable_testTabel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">QueryTableHave</span>(<span class="string">&quot;testTabel&quot;</span>) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        QString strSql = <span class="string">R&quot;(CREATE TABLE logs (</span></span><br><span class="line"><span class="string">			id              integer PRIMARY KEY,</span></span><br><span class="line"><span class="string">  			list1 INTEGER,       	-- 整数类型，例如 1, 100, -5，对应 SQLite 的 INTEGER 存储</span></span><br><span class="line"><span class="string">    		list2 REAL,             -- 浮点数类型，例如 3.14，对应 REAL 存储</span></span><br><span class="line"><span class="string">    		list3 TEXT,             -- 文本类型，可变长字符串，对应 TEXT 存储</span></span><br><span class="line"><span class="string">    		list4 BLOB,             -- 二进制大对象，适合存储图片、音频等二进制数据</span></span><br><span class="line"><span class="string">    		list5 NUMERIC,          -- 数值类型，支持自动解析为整数、浮点或文本</span></span><br><span class="line"><span class="string">    		list6 VARCHAR(100),     -- 可变长度字符串（建议长度），SQLite 会视为 TEXT 存储</span></span><br><span class="line"><span class="string">    		list7 BOOLEAN,          -- 布尔类型，通常用 0/1 存储，SQLite 视为 NUMERIC</span></span><br><span class="line"><span class="string">    		list8 DATETIME,         -- 日期时间类型，通常存为文本或时间戳</span></span><br><span class="line"><span class="string">	list9 DECIMAL(10,3),       -- 精度小数，虽然 SQLite 不强制精度，但语义上表示“10位总数，3位小数”</span></span><br><span class="line"><span class="string">	list10 JSON    -- JSON 字符串（无专用类型，存为 TEXT 或 BLOB），可使用 SQLite 的 JSON 函数处理</span></span><br><span class="line"><span class="string">                );)&quot;</span>;</span><br><span class="line">        succ =  <span class="built_in">CreateTable</span>(strSql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> succ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyDatabaseDB::InsertTo_testTable</span><span class="params">(......)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;dbMutex)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Database open error&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//参数绑定</span></span><br><span class="line">    <span class="comment">//QString sql = &quot;INSERT INTO tableName (dataname) VALUES (:data)&quot;;</span></span><br><span class="line">    <span class="comment">//QSqlQuery query(m_db);</span></span><br><span class="line">    <span class="comment">//query.prepare(sql);</span></span><br><span class="line">    <span class="comment">//query.bindValue(&quot;:data&quot;, data);  // 安全绑定变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//语句拼接</span></span><br><span class="line">    QString sql = <span class="built_in">QString</span>(<span class="string">&quot;INSERT INTO tableName (%1) VALUES (%2)&quot;</span>)</span><br><span class="line">                    .<span class="built_in">arg</span>(<span class="string">&quot;dataname&quot;</span>)</span><br><span class="line">                    .<span class="built_in">arg</span>(data);</span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(m_db)</span></span>;</span><br><span class="line">    query.<span class="built_in">prepare</span>(sql);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!query.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Insert error:&quot;</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;SELECT id, name FROM users&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (query.<span class="built_in">next</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> id = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">    QString name = query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; id &lt;&lt; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📦-总结推荐方案"><a href="#📦-总结推荐方案" class="headerlink" title="📦 总结推荐方案"></a>📦 总结推荐方案</h2><table>
<thead>
<tr>
<th>项目类型</th>
<th>推荐数据库</th>
<th>使用建议</th>
</tr>
</thead>
<tbody><tr>
<td>工控单机&#x2F;嵌入式</td>
<td>SQLite</td>
<td>使用单线程或加锁</td>
</tr>
<tr>
<td>工业网关集中存储</td>
<td>MySQL</td>
<td>数据统一上传管理</td>
</tr>
<tr>
<td>大型分析系统</td>
<td>PostgreSQL</td>
<td>支持复杂事务，功能强大</td>
</tr>
<tr>
<td>缓存&#x2F;实时任务</td>
<td>Redis</td>
<td>搭配主数据库使用</td>
</tr>
<tr>
<td>数据结构变化频繁</td>
<td>MongoDB</td>
<td>Schema灵活，但不适合强一致性业务</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔚-附加说明"><a href="#🔚-附加说明" class="headerlink" title="🔚 附加说明"></a>🔚 附加说明</h2><ul>
<li>SQLite 适合离线和轻量系统，MySQL&#x2F;PostgreSQL 更适合中心化&#x2F;网络化方案。</li>
<li>所有写操作在多线程下都需谨慎控制，建议设计明确的访问策略。</li>
</ul>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 持久化配置文件方案总结</title>
    <url>/2025/07/01/qt_%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>在 Qt 或 C++ 开发中，持久化配置文件必不可少，本文针对各类持久化数据保存方案加以总结。</p>
</blockquote>
<hr>
<h2 id="📌-1-QSettings（推荐方案）"><a href="#📌-1-QSettings（推荐方案）" class="headerlink" title="📌 1. QSettings（推荐方案）"></a>📌 1. QSettings（推荐方案）</h2><h3 id="✅-特点"><a href="#✅-特点" class="headerlink" title="✅ 特点"></a>✅ 特点</h3><ul>
<li>Qt 内置支持，跨平台</li>
<li>可自动读写INI 配置文件（Linux&#x2F;macOS）或  注册表（Windows）</li>
<li>支持分层结构 key（类似 JSON 的路径）</li>
</ul>
<h3 id="🧩示例：创建-QSettings-对象"><a href="#🧩示例：创建-QSettings-对象" class="headerlink" title="🧩示例：创建 QSettings 对象"></a>🧩示例：创建 QSettings 对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString path = QCoreApplication::<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/config.ini&quot;</span>;</span><br><span class="line"><span class="function">QSettings <span class="title">settings</span><span class="params">(path, QSettings::IniFormat)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="🧩-示例：写入-删除-配置"><a href="#🧩-示例：写入-删除-配置" class="headerlink" title="🧩 示例：写入&#x2F;删除 配置"></a>🧩 示例：写入&#x2F;删除 配置</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">settings.<span class="built_in">setValue</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhangbh&quot;</span>);</span><br><span class="line">settings.<span class="built_in">setValue</span>(<span class="string">&quot;window/width&quot;</span>, <span class="number">800</span>);</span><br><span class="line">settings.<span class="built_in">setValue</span>(<span class="string">&quot;window/height&quot;</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">settings.<span class="built_in">remove</span>(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="🧩-示例：读取配置"><a href="#🧩-示例：读取配置" class="headerlink" title="🧩 示例：读取配置"></a>🧩 示例：读取配置</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString username = settings.<span class="built_in">value</span>(<span class="string">&quot;username&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line"><span class="type">int</span> width = settings.<span class="built_in">value</span>(<span class="string">&quot;window/width&quot;</span>).<span class="built_in">toInt</span>();</span><br></pre></td></tr></table></figure>

<h3 id="🗂-config-ini-示例内容："><a href="#🗂-config-ini-示例内容：" class="headerlink" title="🗂 config.ini 示例内容："></a>🗂 config.ini 示例内容：</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[window]</span></span><br><span class="line"><span class="attr">width</span>=<span class="number">800</span></span><br><span class="line"><span class="attr">height</span>=<span class="number">600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">username</span>=zhangbh</span><br></pre></td></tr></table></figure>

<h3 id="📍-注意：默认构造写入注册表（Windows）"><a href="#📍-注意：默认构造写入注册表（Windows）" class="headerlink" title="📍 注意：默认构造写入注册表（Windows）"></a>📍 注意：默认构造写入注册表（Windows）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSettings <span class="title">settings</span><span class="params">(<span class="string">&quot;MyCompany&quot;</span>, <span class="string">&quot;MyApp&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>会写入：</p>
<p>​		<code>Windows: C:/Users/用户名/AppData/Local/YourApp/config.ini</code></p>
<p>​		<code>Linux: ~/.config/YourApp/config.ini</code></p>
<p>可通过 <code>settings.fileName()</code> 查看使用的文件路径（仅限文件格式）</p>
<hr>
<h2 id="📌-2-多个-INI-配置文件"><a href="#📌-2-多个-INI-配置文件" class="headerlink" title="📌 2. 多个 INI 配置文件"></a>📌 2. 多个 INI 配置文件</h2><p>可以使用多个 QSettings 实例分别管理不同配置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSettings <span class="title">userSettings</span><span class="params">(<span class="string">&quot;user.ini&quot;</span>, QSettings::IniFormat)</span></span>;</span><br><span class="line"><span class="function">QSettings <span class="title">windowSettings</span><span class="params">(<span class="string">&quot;window.ini&quot;</span>, QSettings::IniFormat)</span></span>;</span><br><span class="line"><span class="function">QSettings <span class="title">networkSettings</span><span class="params">(<span class="string">&quot;network.ini&quot;</span>, QSettings::IniFormat)</span></span>;</span><br></pre></td></tr></table></figure>

<p>每个文件独立生成，便于模块化管理。</p>
<hr>
<h2 id="📌-3-YAML-配置（借助-yaml-cpp-库）"><a href="#📌-3-YAML-配置（借助-yaml-cpp-库）" class="headerlink" title="📌 3. YAML 配置（借助 yaml-cpp 库）"></a>📌 3. YAML 配置（借助 yaml-cpp 库）</h2><p>Qt 本身不支持 类似于java YAML 那样的配置，可通过 <a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a> 实现：</p>
<p>适用于结构复杂、可读性要求高的配置文件。</p>
<p>推荐方案：<strong>使用 yaml-cpp 源码 + CMake 配置为静态库</strong></p>
<p>（详细方案已载入本博客，请自行搜索）</p>
<hr>
<h2 id="📌-4-JSON-配置文件"><a href="#📌-4-JSON-配置文件" class="headerlink" title="📌 4. JSON 配置文件"></a>📌 4. JSON 配置文件</h2><ul>
<li>读取配置文件（config.json）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;config.json&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">    <span class="built_in">qWarning</span>(<span class="string">&quot;无法打开配置文件！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QByteArray data = file.<span class="built_in">readAll</span>();</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">QJsonParseError parseError;</span><br><span class="line">QJsonDocument doc = QJsonDocument::<span class="built_in">fromJson</span>(data, &amp;parseError);</span><br><span class="line"><span class="keyword">if</span> (parseError.error != QJsonParseError::NoError) &#123;</span><br><span class="line">    <span class="built_in">qWarning</span>(<span class="string">&quot;JSON 解析失败: %s&quot;</span>, <span class="built_in">qPrintable</span>(parseError.<span class="built_in">errorString</span>()));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QJsonObject obj = doc.<span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width = obj[<span class="string">&quot;window&quot;</span>].<span class="built_in">toObject</span>()[<span class="string">&quot;width&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line"><span class="type">int</span> height = obj[<span class="string">&quot;window&quot;</span>].<span class="built_in">toObject</span>()[<span class="string">&quot;height&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">QString username = obj[<span class="string">&quot;username&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line"><span class="type">bool</span> autoLogin = obj[<span class="string">&quot;autoLogin&quot;</span>].<span class="built_in">toBool</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;读取成功：&quot;</span> &lt;&lt; width &lt;&lt; height &lt;&lt; username &lt;&lt; autoLogin;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改并保存配置：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改配置内容</span></span><br><span class="line"><span class="comment">// obj[&quot;window&quot;].toObject()[&quot;width&quot;] = 1024;  // ❌ 不能直接改，需拆出来改后再设置回去</span></span><br><span class="line">QJsonObject windowObj = obj[<span class="string">&quot;window&quot;</span>].<span class="built_in">toObject</span>();</span><br><span class="line">windowObj[<span class="string">&quot;width&quot;</span>] = <span class="number">1024</span>;</span><br><span class="line">windowObj[<span class="string">&quot;height&quot;</span>] = <span class="number">768</span>;</span><br><span class="line">obj[<span class="string">&quot;window&quot;</span>] = windowObj;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">&quot;username&quot;</span>] = <span class="string">&quot;new_user&quot;</span>;</span><br><span class="line">obj[<span class="string">&quot;autoLogin&quot;</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新字段：language</span></span><br><span class="line">obj[<span class="string">&quot;language&quot;</span>] = <span class="string">&quot;zh-CN&quot;</span>;</span><br><span class="line"><span class="comment">// 添加新子对象</span></span><br><span class="line">QJsonObject theme;</span><br><span class="line">theme[<span class="string">&quot;background&quot;</span>] = <span class="string">&quot;#ffffff&quot;</span>;</span><br><span class="line">theme[<span class="string">&quot;font&quot;</span>] = <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">obj[<span class="string">&quot;theme&quot;</span>] = theme;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除单个字段</span></span><br><span class="line">obj.<span class="built_in">remove</span>(<span class="string">&quot;autoLogin&quot;</span>);</span><br><span class="line"><span class="comment">// 删除 window 子字段中的某个键</span></span><br><span class="line">QJsonObject windowObj = obj[<span class="string">&quot;window&quot;</span>].<span class="built_in">toObject</span>();</span><br><span class="line">windowObj.<span class="built_in">remove</span>(<span class="string">&quot;height&quot;</span>);</span><br><span class="line">obj[<span class="string">&quot;window&quot;</span>] = windowObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存到文件 (“清空重写”整个文件内容)</span></span><br><span class="line"><span class="function">QJsonDocument <span class="title">saveDoc</span><span class="params">(obj)</span></span>;</span><br><span class="line"><span class="function">QFile <span class="title">saveFile</span><span class="params">(<span class="string">&quot;config.json&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!saveFile.<span class="built_in">open</span>(QIODevice::WriteOnly)) &#123;</span><br><span class="line">    <span class="built_in">qWarning</span>(<span class="string">&quot;无法写入配置文件！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">saveFile.<span class="built_in">write</span>(saveDoc.<span class="built_in">toJson</span>(QJsonDocument::Indented));</span><br><span class="line">saveFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>config.json</code> 结构示例：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;window&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">800</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">600</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangbh&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;autoLogin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="📌-5-XML-配置文件"><a href="#📌-5-XML-配置文件" class="headerlink" title="📌 5. XML 配置文件"></a>📌 5. XML 配置文件</h2><p>使用 <code>QDomDocument</code> 实现，适用于需要带结构和注释的场景。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.pro添加 QT += xml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDomDocument&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readVideoDevices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QDomDocument doc;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;config.xml&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly) || !doc.<span class="built_in">setContent</span>(&amp;file)) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;加载XML失败&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    file.<span class="built_in">close</span>();  <span class="comment">// 读取完成后关闭文件</span></span><br><span class="line"></span><br><span class="line">    QDomElement root = doc.<span class="built_in">documentElement</span>();  <span class="comment">// &lt;config&gt;</span></span><br><span class="line">    QDomElement devices = root.<span class="built_in">firstChildElement</span>(<span class="string">&quot;devices&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有&lt;devices&gt;节点</span></span><br><span class="line">    <span class="keyword">while</span> (!devices.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (devices.<span class="built_in">attribute</span>(<span class="string">&quot;type&quot;</span>) == <span class="string">&quot;video&quot;</span>) &#123;  <span class="comment">// 筛选type为video</span></span><br><span class="line">            QDomElement dev = devices.<span class="built_in">firstChildElement</span>(<span class="string">&quot;device&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历&lt;device&gt;节点</span></span><br><span class="line">            <span class="keyword">while</span> (!dev.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">                QString id = dev.<span class="built_in">attribute</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                QString name = dev.<span class="built_in">attribute</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                QString ip = dev.<span class="built_in">attribute</span>(<span class="string">&quot;ip&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;名称:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;IP:&quot;</span> &lt;&lt; ip;</span><br><span class="line">                dev = dev.<span class="built_in">nextSiblingElement</span>(<span class="string">&quot;device&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devices = devices.<span class="built_in">nextSiblingElement</span>(<span class="string">&quot;devices&quot;</span>);  <span class="comment">// 下一个&lt;devices&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">devices</span> <span class="attr">type</span>=<span class="string">&quot;video&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">device</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Camera1&quot;</span> <span class="attr">ip</span>=<span class="string">&quot;192.168.1.10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">device</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Camera2&quot;</span> <span class="attr">ip</span>=<span class="string">&quot;192.168.1.11&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">devices</span> <span class="attr">type</span>=<span class="string">&quot;sensor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">device</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">name</span>=<span class="string">&quot;TempSensor&quot;</span> <span class="attr">ip</span>=<span class="string">&quot;192.168.1.20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>QDomDocument</code> 采用**完整树结构（DOM）**的方式把整个 XML 文件加载到内存，适合处理几百 KB 以内的配置类 XML 文件</p>
</li>
<li><p>使用 <code>QXmlStreamReader</code> &#x2F; <code>QXmlStreamWriter</code>（推荐）Qt 的流式 XML 读取&#x2F;写入 AP，类似于 SAX 的模式，不需要将整个文档加载到内存中。</p>
</li>
<li><p>❌蛮麻烦的，需要具体问题具体分析，这里不做示例，涉及到频繁的增删改查建议使用别的持久化方案。</p>
</li>
</ul>
<hr>
<h2 id="✅-建议总结"><a href="#✅-建议总结" class="headerlink" title="✅ 建议总结"></a>✅ 建议总结</h2><table>
<thead>
<tr>
<th>配置方式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>QSettings</td>
<td>简洁、自动存储、跨平台</td>
<td>不支持注释</td>
<td>日常开发配置，快速保存读取</td>
</tr>
<tr>
<td>JSON</td>
<td>结构清晰，易于解析</td>
<td>不支持注释</td>
<td>嵌套配置、API交互配置</td>
</tr>
<tr>
<td>YAML</td>
<td>可读性强、支持注释</td>
<td>需第三方库</td>
<td>高级配置需求、人读写场景</td>
</tr>
<tr>
<td>XML</td>
<td>可扩展性强、支持注释</td>
<td>编写较繁琐</td>
<td>配置与描述性结合的场景</td>
</tr>
<tr>
<td>多个 INI</td>
<td>模块分离、便于分类管理</td>
<td>文件多略显分散</td>
<td>多模块配置、多环境配置</td>
</tr>
</tbody></table>
<hr>
<h2 id="📍-注：文件路径说明"><a href="#📍-注：文件路径说明" class="headerlink" title="📍 注：文件路径说明"></a>📍 注：文件路径说明</h2><table>
<thead>
<tr>
<th>Qt 方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>QDir::currentPath()</code></td>
<td>当前运行目录（默认是 build 目录）</td>
</tr>
<tr>
<td><code>QCoreApplication::applicationDirPath()</code></td>
<td>可执行文件所在目录（.exe 所在）</td>
</tr>
<tr>
<td><code>QStandardPaths::writableLocation()</code></td>
<td>系统标准配置路径（推荐用于正式部署）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>锁机制与类型详解（C++ / Qt）</title>
    <url>/2025/06/15/%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>本文针对于（C++ &#x2F; Qt）互斥访问机制，即各类互斥锁进行了详细说明，并简要介绍了QT和C++的锁管理工具。</p>
</blockquote>
<hr>
<h2 id="一、什么是锁机制？"><a href="#一、什么是锁机制？" class="headerlink" title="一、什么是锁机制？"></a>一、什么是锁机制？</h2><p>锁机制（Lock Mechanism）是一种并发控制手段，用于防止多个线程同时访问共享资源，以避免数据竞争（Race Condition）和数据不一致。</p>
<p>其本质是通过一个“互斥标志”控制临界区的访问。</p>
<hr>
<h2 id="二、锁的基本原理"><a href="#二、锁的基本原理" class="headerlink" title="二、锁的基本原理"></a>二、锁的基本原理</h2><ul>
<li>多个线程访问共享资源时必须使用锁。</li>
<li><strong>一个时刻只能有一个线程进入锁保护的代码块</strong>。</li>
<li>其余线程会被阻塞，直到锁被释放。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex.<span class="built_in">lock</span>();     <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    mutex.<span class="built_in">unlock</span>();   <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更安全的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex)</span></span>;  <span class="comment">// 自动加锁 + 自动释放（RAII）</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、常见锁类型"><a href="#三、常见锁类型" class="headerlink" title="三、常见锁类型"></a>三、常见锁类型</h2><table>
<thead>
<tr>
<th>锁类型</th>
<th>类名</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>互斥锁</strong></td>
<td><code>QMutex</code> &#x2F; <code>std::mutex</code></td>
<td>最基本的锁，互斥访问临界区</td>
<td>一般共享资源保护</td>
</tr>
<tr>
<td><strong>递归锁</strong></td>
<td><code>QRecursiveMutex</code> &#x2F; <code>std::recursive_mutex</code></td>
<td>同一线程可重复加锁</td>
<td>同一函数递归&#x2F;多层调用需锁</td>
</tr>
<tr>
<td><strong>读写锁</strong></td>
<td><code>QReadWriteLock</code> &#x2F; <code>std::shared_mutex</code></td>
<td>多读单写，提高读效率</td>
<td>读多写少的场景，如缓存、配置</td>
</tr>
<tr>
<td><strong>信号量</strong></td>
<td><code>QSemaphore</code> &#x2F; <code>std::counting_semaphore</code></td>
<td>控制并发线程数量</td>
<td>连接池、限流器</td>
</tr>
<tr>
<td><strong>条件变量</strong></td>
<td><code>QWaitCondition</code> &#x2F; <code>std::condition_variable</code></td>
<td>配合互斥锁，进行线程阻塞与唤醒</td>
<td>线程同步、生产者消费者模型</td>
</tr>
<tr>
<td><strong>原子变量</strong></td>
<td><code>std::atomic&lt;T&gt;</code></td>
<td>无锁操作，底层使用原子指令</td>
<td>简单变量并发安全处理</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、各类锁详细说明"><a href="#四、各类锁详细说明" class="headerlink" title="四、各类锁详细说明"></a>四、各类锁详细说明</h2><h3 id="1-QMutex-std-mutex"><a href="#1-QMutex-std-mutex" class="headerlink" title="1. QMutex &#x2F; std::mutex"></a>1. QMutex &#x2F; std::mutex</h3><ul>
<li>最常见互斥锁。</li>
<li>多线程访问共享资源时，使用加锁&#x2F;解锁控制。</li>
<li>Qt 推荐配合 <code>QMutexLocker</code> 使用，C++ 推荐 <code>std::lock_guard</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMutex mutex;</span><br><span class="line"><span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex)</span></span>; <span class="comment">// 推荐方式</span></span><br></pre></td></tr></table></figure>

<h3 id="2-QRecursiveMutex-std-recursive-mutex"><a href="#2-QRecursiveMutex-std-recursive-mutex" class="headerlink" title="2. QRecursiveMutex &#x2F; std::recursive_mutex"></a>2. QRecursiveMutex &#x2F; std::recursive_mutex</h3><ul>
<li>支持<strong>同一线程重复加锁</strong>，但需要对应次数解锁。</li>
<li>如果你递归调用了某个需要加锁的函数，使用递归锁可避免死锁。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QRecursiveMutex rmutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;rmutex)</span></span>;</span><br><span class="line">    <span class="built_in">foo</span>(); <span class="comment">// 递归安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-QReadWriteLock-std-shared-mutex"><a href="#3-QReadWriteLock-std-shared-mutex" class="headerlink" title="3. QReadWriteLock &#x2F; std::shared_mutex"></a>3. QReadWriteLock &#x2F; std::shared_mutex</h3><ul>
<li><strong>多个线程可同时读</strong>，但写时独占。</li>
<li>如果你有大量读操作，读写锁可提升性能。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QReadWriteLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程</span></span><br><span class="line">lock.<span class="built_in">lockForRead</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写线程</span></span><br><span class="line">lock.<span class="built_in">lockForWrite</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<h3 id="4-QSemaphore-std-counting-semaphore"><a href="#4-QSemaphore-std-counting-semaphore" class="headerlink" title="4. QSemaphore &#x2F; std::counting_semaphore"></a>4. QSemaphore &#x2F; std::counting_semaphore</h3><ul>
<li>表示<strong>资源数量</strong>，可以控制同时访问某资源的线程数。</li>
<li>类似“通行证”，每次 <code>acquire()</code> 消耗一个，<code>release()</code> 归还一个。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSemaphore <span class="title">sem</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 最多允许3个线程同时进入</span></span><br><span class="line">sem.<span class="built_in">acquire</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">sem.<span class="built_in">release</span>();</span><br></pre></td></tr></table></figure>

<h3 id="5-QWaitCondition-std-condition-variable"><a href="#5-QWaitCondition-std-condition-variable" class="headerlink" title="5. QWaitCondition &#x2F; std::condition_variable"></a>5. QWaitCondition &#x2F; std::condition_variable</h3><ul>
<li>用于<strong>线程阻塞与唤醒</strong>。</li>
<li>通常与 <code>QMutex</code> 配合，在线程需要等待某个条件达成时使用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMutex mutex;</span><br><span class="line">QWaitCondition cond;</span><br><span class="line"></span><br><span class="line">mutex.<span class="built_in">lock</span>();</span><br><span class="line">cond.<span class="built_in">wait</span>(&amp;mutex);  <span class="comment">// 阻塞等待</span></span><br><span class="line">mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">cond.<span class="built_in">wakeOne</span>(); <span class="comment">// 唤醒一个等待线程</span></span><br></pre></td></tr></table></figure>

<h3 id="6-std-atomic"><a href="#6-std-atomic" class="headerlink" title="6. std::atomic"></a>6. std::atomic<T></h3><ul>
<li>C++ 原子类型，<strong>无锁</strong>实现线程安全的变量访问。</li>
<li>适用于简单的数值类型（如 int、bool）等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">count++;   <span class="comment">// 原子自增，无需加锁</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、锁管理工具"><a href="#五、锁管理工具" class="headerlink" title="五、锁管理工具"></a>五、锁管理工具</h2><h3 id="1-Qt-和-C-锁管理工具的对比"><a href="#1-Qt-和-C-锁管理工具的对比" class="headerlink" title="1. Qt 和 C++ 锁管理工具的对比"></a>1. Qt 和 C++ 锁管理工具的对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Qt (<code>QMutexLocker</code>)</th>
<th>C++ (<code>std::lock_guard</code> &#x2F; <code>std::unique_lock</code>)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>自动加锁与解锁</strong></td>
<td>✅ 自动加锁、自动解锁</td>
<td>✅ 自动加锁、自动解锁（<code>std::lock_guard</code>）</td>
</tr>
<tr>
<td><strong>手动解锁支持</strong></td>
<td>❌ 不支持</td>
<td>✅ 支持（<code>std::unique_lock</code>）</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>❌ 只支持简单加锁</td>
<td>✅ 支持更复杂的加锁和解锁场景（<code>std::unique_lock</code>）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较高（简化）</td>
<td><code>std::lock_guard</code> 较轻，<code>std::unique_lock</code> 较重</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单加锁保护</td>
<td>简单加锁（<code>std::lock_guard</code>）、复杂加锁（<code>std::unique_lock</code>）</td>
</tr>
<tr>
<td><strong>平台支持</strong></td>
<td>仅 Qt</td>
<td>C++ 标准库（跨平台）</td>
</tr>
</tbody></table>
<h3 id="2-Qt：QMutexLocker"><a href="#2-Qt：QMutexLocker" class="headerlink" title="2. Qt：QMutexLocker"></a>2. Qt：<code>QMutexLocker</code></h3><ul>
<li><strong>作用</strong>：<code>QMutexLocker</code> 是 Qt 提供的一个简化加锁的工具。它遵循 <strong>RAII</strong>（资源获取即初始化）模式，自动加锁和自动解锁。</li>
<li><strong>使用场景</strong>：适合在简单的锁保护场景中使用。自动管理锁，避免手动管理时可能发生的错误（如忘记解锁）。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">cpp复制编辑QMutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> func() &#123;</span><br><span class="line">    QMutexLocker locker(&amp;mutex);  <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;  <span class="comment">// 离开作用域时自动解锁</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：<ul>
<li>自动加锁和解锁，避免忘记解锁的风险。</li>
<li>适用于简单的临界区保护。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>只支持自动加锁和解锁，不支持手动解锁。</li>
</ul>
</li>
</ul>
<h3 id="3-C-：std-lock-guard"><a href="#3-C-：std-lock-guard" class="headerlink" title="3. C++：std::lock_guard"></a>3. C++：<code>std::lock_guard</code></h3><ul>
<li><strong>作用</strong>：<code>std::lock_guard</code> 是 C++11 中引入的锁管理工具。它也遵循 <strong>RAII</strong> 模式，自动管理锁。</li>
<li><strong>使用场景</strong>：适用于简单的加锁保护，不需要手动解锁的场景。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpp复制编辑<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;  <span class="comment">// 离开作用域时自动解锁</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：<ul>
<li>自动加锁和解锁，避免手动解锁的问题。</li>
<li>适用于简单的加锁保护，代码简洁。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>只支持自动加锁和解锁，不支持手动解锁。</li>
</ul>
</li>
</ul>
<h3 id="4-C-：std-unique-lock"><a href="#4-C-：std-unique-lock" class="headerlink" title="4. C++：std::unique_lock"></a>4. C++：<code>std::unique_lock</code></h3><ul>
<li><strong>作用</strong>：<code>std::unique_lock</code> 是 C++11 引入的一个更灵活的锁管理工具。它支持自动加锁、手动解锁、重新加锁等功能。</li>
<li><strong>使用场景</strong>：适用于需要灵活控制锁的场景，例如需要延迟加锁或手动解锁的情况。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpp复制编辑<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line"></span><br><span class="line">    lock.<span class="built_in">unlock</span>();  <span class="comment">// 手动解锁</span></span><br><span class="line">    <span class="comment">// 其他操作</span></span><br><span class="line"></span><br><span class="line">    lock.<span class="built_in">lock</span>();    <span class="comment">// 重新加锁</span></span><br><span class="line">&#125;  <span class="comment">// 离开作用域时自动解锁</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：<ul>
<li>支持灵活的锁管理，可以手动解锁和重新加锁。</li>
<li>在更复杂的多线程场景中非常有用。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>比 <code>std::lock_guard</code> 稍重，性能开销更大。</li>
</ul>
</li>
</ul>
<h2 id="六、常见问题与注意事项"><a href="#六、常见问题与注意事项" class="headerlink" title="六、常见问题与注意事项"></a>六、常见问题与注意事项</h2><h3 id="1-是否锁住了变量？"><a href="#1-是否锁住了变量？" class="headerlink" title="1. 是否锁住了变量？"></a>1. 是否锁住了变量？</h3><blockquote>
<p>❌ 锁住的不是变量，而是访问变量的代码块。<br>✅ 只有所有访问路径都加锁，才能保证线程安全。</p>
</blockquote>
<h3 id="2-死锁问题"><a href="#2-死锁问题" class="headerlink" title="2. 死锁问题"></a>2. 死锁问题</h3><ul>
<li>多个线程<strong>循环等待对方释放锁</strong>会造成程序永久卡住。</li>
<li>建议统一加锁顺序，避免多个线程互相等待。</li>
</ul>
<h3 id="3-性能损耗"><a href="#3-性能损耗" class="headerlink" title="3. 性能损耗"></a>3. 性能损耗</h3><ul>
<li>过多加锁会导致线程频繁切换，影响性能。</li>
<li>优化策略：缩小临界区、使用读写锁、用原子变量代替锁。</li>
</ul>
<hr>
<h2 id="七、锁机制示意图"><a href="#七、锁机制示意图" class="headerlink" title="七、锁机制示意图"></a>七、锁机制示意图</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">线程A         线程B</span><br><span class="line">  |              |</span><br><span class="line">lock(mutex)    lock(mutex)  &lt;-- 阻塞等待</span><br><span class="line">  |              |</span><br><span class="line">[临界区]        等待中</span><br><span class="line">  |              |</span><br><span class="line">unlock(mutex)   获得锁后执行</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><ul>
<li>加锁保护的是代码块，不是变量本身 </li>
<li>所有访问共享资源的路径都必须加锁 </li>
<li>推荐使用 RAII 风格管理锁（如 QMutexLocker） </li>
<li>对简单变量推荐使用 <code>std::atomic</code> 替代锁 </li>
<li>注意死锁、性能、调试成本问题</li>
</ul>
<p>如需更高级的并发模型，还可以考虑 Qt Concurrent、线程池（<code>QThreadPool</code>）、任务队列等方式。</p>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程中的线程安全策略详解</title>
    <url>/2025/06/14/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>本文详细整理了保证线程安全的各种常用手段，包括加锁、原子操作、线程间通信、设计模式等，适合 C++ &#x2F; Qt 开发者参考使用。</p>
</blockquote>
<hr>
<h2 id="一、同步机制（保护共享资源）"><a href="#一、同步机制（保护共享资源）" class="headerlink" title="一、同步机制（保护共享资源）"></a>一、同步机制（保护共享资源）</h2><h3 id="1-加锁（Mutex）"><a href="#1-加锁（Mutex）" class="headerlink" title="1. 加锁（Mutex）"></a>1. 加锁（Mutex）</h3><blockquote>
<p>最常见，也是最通用的线程同步手段。</p>
</blockquote>
<ul>
<li>C++: <code>std::mutex</code> &#x2F; <code>std::recursive_mutex</code> &#x2F; <code>std::shared_mutex</code></li>
<li>Qt: <code>QMutex</code> &#x2F; <code>QReadWriteLock</code></li>
</ul>
<h4 id="示例（C-11）："><a href="#示例（C-11）：" class="headerlink" title="示例（C++11）："></a>示例（C++11）：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadSafeFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="推荐使用-RAII-写法："><a href="#推荐使用-RAII-写法：" class="headerlink" title="推荐使用 RAII 写法："></a>推荐使用 RAII 写法：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁和解锁</span></span><br></pre></td></tr></table></figure>

<h4 id="Qt-中推荐使用："><a href="#Qt-中推荐使用：" class="headerlink" title="Qt 中推荐使用："></a>Qt 中推荐使用：</h4><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QMutexLocker locker(&amp;m_mutex); <span class="comment">// 自动加锁/解锁</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-原子操作（Atomic）"><a href="#2-原子操作（Atomic）" class="headerlink" title="2. 原子操作（Atomic）"></a>2. 原子操作（Atomic）</h3><p>用于<strong>无需加锁的简单变量</strong>操作，性能更好。</p>
<ul>
<li>Qt: <code>QAtomicInt</code>, <code>QAtomicPointer</code></li>
<li>C++: <code>std::atomic</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter = <span class="number">0</span>;</span><br><span class="line">counter++;</span><br></pre></td></tr></table></figure>

<p>适用于：计数器、自增ID等场景。</p>
<hr>
<h3 id="3-条件变量（Condition-Variable）"><a href="#3-条件变量（Condition-Variable）" class="headerlink" title="3. 条件变量（Condition Variable）"></a>3. 条件变量（Condition Variable）</h3><p>用于线程间协作，<strong>一个线程等待条件达成后继续执行</strong>。</p>
<ul>
<li>C++: <code>std::condition_variable</code></li>
<li>Qt: <code>QWaitCondition</code></li>
</ul>
<hr>
<h2 id="二、线程间通信机制"><a href="#二、线程间通信机制" class="headerlink" title="二、线程间通信机制"></a>二、线程间通信机制</h2><h3 id="1-Qt-信号槽机制（推荐）"><a href="#1-Qt-信号槽机制（推荐）" class="headerlink" title="1. Qt 信号槽机制（推荐）"></a>1. Qt 信号槽机制（推荐）</h3><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">connect(worker, &amp;<span class="attribute">Worker</span>::finished, <span class="keyword">this</span>, &amp;<span class="attribute">MainWindow</span>::onWorkerDone, <span class="attribute">Qt</span>::QueuedConnection);</span><br></pre></td></tr></table></figure>

<ul>
<li>跨线程使用 <code>Qt::QueuedConnection</code>，自动排队处理，<strong>避免并发冲突</strong>。</li>
</ul>
<hr>
<h3 id="2-消息队列-环形缓冲区"><a href="#2-消息队列-环形缓冲区" class="headerlink" title="2. 消息队列 &#x2F; 环形缓冲区"></a>2. 消息队列 &#x2F; 环形缓冲区</h3><ul>
<li>自定义线程安全队列（带锁或无锁）</li>
<li>用于：生产者-消费者模型，数据采集、任务队列</li>
</ul>
<hr>
<h2 id="三、设计层面策略"><a href="#三、设计层面策略" class="headerlink" title="三、设计层面策略"></a>三、设计层面策略</h2><h3 id="1-线程封闭（Thread-Confinement）"><a href="#1-线程封闭（Thread-Confinement）" class="headerlink" title="1. 线程封闭（Thread Confinement）"></a>1. 线程封闭（Thread Confinement）</h3><blockquote>
<p>保证某资源只由一个线程访问，<strong>不共享</strong>，自然线程安全。</p>
</blockquote>
<p>例如：每个线程拥有独立数据库连接、日志文件句柄等。</p>
<hr>
<h3 id="2-不可变对象（Immutable）"><a href="#2-不可变对象（Immutable）" class="headerlink" title="2. 不可变对象（Immutable）"></a>2. 不可变对象（Immutable）</h3><p>不可变对象在多线程环境下可以安全共享：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> QString config = <span class="string">&quot;setting.conf&quot;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-拷贝而非共享（Copy-on-write）"><a href="#3-拷贝而非共享（Copy-on-write）" class="headerlink" title="3. 拷贝而非共享（Copy-on-write）"></a>3. 拷贝而非共享（Copy-on-write）</h3><p>Qt 容器和 QString 默认实现了写时复制（隐式共享），如：</p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QString a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">QString b = a; <span class="comment">// 实际未复制，直到 b 修改时才复制</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、现代语言机制支持"><a href="#四、现代语言机制支持" class="headerlink" title="四、现代语言机制支持"></a>四、现代语言机制支持</h2><h3 id="1-std-future-std-promise（C-11）"><a href="#1-std-future-std-promise（C-11）" class="headerlink" title="1. std::future &#x2F; std::promise（C++11）"></a>1. <code>std::future</code> &#x2F; <code>std::promise</code>（C++11）</h3><p>支持线程返回值、异步等待：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>([]()&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;);</span><br><span class="line"><span class="type">int</span> value = result.<span class="built_in">get</span>(); <span class="comment">// 等待并获取结果</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-QtConcurrent（高级并行框架）"><a href="#2-QtConcurrent（高级并行框架）" class="headerlink" title="2. QtConcurrent（高级并行框架）"></a>2. QtConcurrent（高级并行框架）</h3><p>适用于并行处理容器、图像数据等：</p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QFuture&lt;<span class="built_in">int</span>&gt; future = <span class="attribute">QtConcurrent</span>::run(myFunction);</span><br></pre></td></tr></table></figure>

<p>通过 <code>QFutureWatcher</code> 接收回调。</p>
<hr>
<h2 id="五、其他辅助建议"><a href="#五、其他辅助建议" class="headerlink" title="五、其他辅助建议"></a>五、其他辅助建议</h2><table>
<thead>
<tr>
<th>建议</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 缩小锁粒度</td>
<td>尽量缩小加锁代码范围，提升性能</td>
</tr>
<tr>
<td>✅ 避免死锁</td>
<td>保证加锁顺序一致，少用嵌套锁</td>
</tr>
<tr>
<td>✅ 多用值传递，少用共享</td>
<td>倾向局部变量，减少共享资源</td>
</tr>
<tr>
<td>✅ 使用线程池</td>
<td>避免频繁创建&#x2F;销毁线程，统一管理资源</td>
</tr>
</tbody></table>
<hr>
<h2 id="六、典型线程安全写法（Qt）"><a href="#六、典型线程安全写法（Qt）" class="headerlink" title="六、典型线程安全写法（Qt）"></a>六、典型线程安全写法（Qt）</h2><figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">class <span class="title">MyClass</span> &#123;</span><br><span class="line"><span class="attribute">private</span>:</span><br><span class="line">    QMutex m_mutex;</span><br><span class="line">    <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">    <span class="keyword">void</span> increment() &#123;</span><br><span class="line">        QMutexLocker locker(&amp;m_mutex);</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>线程安全的目标是：<strong>多个线程访问共享资源时不发生冲突</strong>。加锁只是手段之一，合理的架构设计、并发模型和工具选择也非常关键。</p>
<p>如有更复杂的线程需求，如线程池、异步通信、跨线程 GUI 操作等，建议结合 QtConcurrent &#x2F; QThread &#x2F; QMetaObject::invokeMethod 进一步扩展。</p>
]]></content>
      <categories>
        <category>QT_知识总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
        <tag>线程</tag>
      </tags>
  </entry>
</search>
